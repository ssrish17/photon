From 328d23d18ae829a2bc26a75a6d41c14f67020cf8 Mon Sep 17 00:00:00 2001
From: Keerthana K <keerthana.kalyanasundaram@broadcom.com>
Date: Wed, 3 Apr 2024 10:56:21 +0000
Subject: [PATCH] gcc rap plugin with kcfi

This patch adopts the forward-edge control-flow integrity
scheme for Clang known as KCFI in gcc with the help
of RAP plugin.

The original RAP gcc plugin code developed by PaX team
is modified to adopt to kcfi implementation in kernel.

Following changes are made to adopt KCFI in GCC RAP plugin:

- Padding and hash size is changed to match with KCFI
- Function label and size paramter are added
  E.g:
0000000000000000 <__cfi_func>:
       0:       cc                      int3
       1:       cc                      int3
       2:       b8 a7 9e 9e 58          mov    $0x589e9ea7,%eax
       7:       cc                      int3
       8:       cc                      int3
- weak attribute handling and skip generation of rap hash
  for direct calls
- change the runtime comparison injection code of RAP plugin
  to use 4 bytes hash comparision instead of 8 bytes
- Add Kconfig changes to enable CFI_CLANG when PAX_RAP is 'y'
- Fix rap_hash injection for bpf_prog_run() to use int instead of
  long as the size of rap_hash is 4 bytes now
- KCFI code adds SYM_TYPED_FUNC_START which emits the type identifier
  before the assembly functions that are called indirectly from C code.
  As the padding and size of cfi_type and rap_hash_type is different,
  replaced __CFI_TYPE macro with __RAP_TYPE for adding rap_hash for
  callers of SYM_TYPED_FUNC_START when CONFIG_PAX_RAP is enabled.

Signed-off-by: Keerthana K <keerthana.kalyanasundaram@broadcom.com>
[Ankit: Upstream commmit:
https://github.com/gregkh/linux/commit/74fcb181772e5b8a8f1244c7393c56ae6d03c330
replaced indirect way of calling system call with switch statement based
direct system call. So, there is no need for asm way to call syscall directly.]
Signed-off-by: Ankit Jain <ankit-aj.jain@broadcom.com>
---
 Makefile                                      |   2 +
 arch/Kconfig                                  |   8 +-
 arch/x86/entry/Makefile                       |   2 +
 arch/x86/include/asm/linkage.h                |   8 +
 arch/x86/include/asm/text-patching.h          |   4 +
 arch/x86/include/asm/vermagic.h               |   9 +-
 arch/x86/kernel/alternative.c                 |   7 +
 arch/x86/kernel/cpu/vmware.c                  |   9 +-
 arch/x86/kernel/module.c                      |   6 +-
 arch/x86/kernel/paravirt.c                    |   7 +-
 arch/x86/kernel/traps.c                       |   4 +
 arch/x86/tools/relocs.c                       |   1 +
 drivers/block/floppy.c                        |  11 +-
 drivers/char/tpm/tpm-chip.c                   |   9 +-
 drivers/firmware/dmi-id.c                     |   7 +-
 drivers/net/ethernet/brocade/bna/bfa_cs.h     |  42 +-
 drivers/net/ethernet/brocade/bna/bfa_ioc.c    |  10 +-
 drivers/net/ethernet/brocade/bna/bfa_ioc.h    |   4 +-
 drivers/net/ethernet/brocade/bna/bfa_msgq.h   |   8 +-
 drivers/net/ethernet/brocade/bna/bna_enet.c   |   6 +-
 drivers/net/ethernet/brocade/bna/bna_tx_rx.c  |   6 +-
 drivers/net/ethernet/brocade/bna/bna_types.h  |  24 +-
 drivers/net/ethernet/brocade/bna/bnad.c       |  11 +-
 drivers/scsi/bfa/bfa.h                        |   4 +-
 drivers/scsi/bfa/bfa_cs.h                     | 124 +++-
 drivers/scsi/bfa/bfa_fcpim.h                  |  12 +-
 drivers/scsi/bfa/bfa_fcs.h                    |  34 +-
 drivers/scsi/bfa/bfa_fcs_fcpim.c              |   6 +-
 drivers/scsi/bfa/bfa_fcs_lport.c              |   4 +-
 drivers/scsi/bfa/bfa_fcs_rport.c              |   4 +-
 drivers/scsi/bfa/bfa_ioc.c                    |   8 +-
 drivers/scsi/bfa/bfa_ioc.h                    |  12 +-
 drivers/scsi/bfa/bfa_svc.c                    |  12 +-
 drivers/scsi/bfa/bfa_svc.h                    |  20 +-
 drivers/scsi/bfa/bfad.c                       |  12 +-
 drivers/scsi/bfa/bfad_drv.h                   |   5 +-
 drivers/scsi/csiostor/csio_defs.h             |  19 +-
 drivers/scsi/csiostor/csio_hw.c               |  69 ++-
 drivers/scsi/csiostor/csio_init.c             |   2 +-
 drivers/scsi/csiostor/csio_lnode.c            |  32 +-
 drivers/scsi/csiostor/csio_rnode.c            |  28 +-
 drivers/scsi/csiostor/csio_scsi.c             |  37 +-
 include/linux/cfi_types.h                     |   8 +
 include/linux/compiler_types.h                |   4 +
 include/linux/moduleparam.h                   |   4 +-
 include/linux/pci.h                           |   2 +-
 include/linux/syscalls.h                      |  17 +-
 kernel/bpf/core.c                             |  21 +-
 kernel/events/core.c                          |   3 +-
 kernel/module/main.c                          |   9 +-
 kernel/sched/core.c                           |   2 +-
 net/bridge/br_private.h                       |   3 +-
 net/netfilter/ipset/ip_set_core.c             |   1 -
 scripts/Makefile.gcc-plugins                  |  12 +
 scripts/gcc-plugins/Makefile                  |   4 +-
 scripts/gcc-plugins/rap_plugin/rap.h          |  38 ++
 .../gcc-plugins/rap_plugin/rap_fptr_pass.c    | 224 +++++++
 scripts/gcc-plugins/rap_plugin/rap_hash.c     | 396 +++++++++++++
 scripts/gcc-plugins/rap_plugin/rap_plugin.c   | 553 ++++++++++++++++++
 scripts/gcc-plugins/rap_plugin/sip.c          |  96 +++
 scripts/mod/modpost.c                         |   6 -
 security/Kconfig                              |  29 +
 security/apparmor/net.c                       |   2 +-
 63 files changed, 1894 insertions(+), 189 deletions(-)
 create mode 100644 scripts/gcc-plugins/rap_plugin/rap.h
 create mode 100644 scripts/gcc-plugins/rap_plugin/rap_fptr_pass.c
 create mode 100644 scripts/gcc-plugins/rap_plugin/rap_hash.c
 create mode 100644 scripts/gcc-plugins/rap_plugin/rap_plugin.c
 create mode 100644 scripts/gcc-plugins/rap_plugin/sip.c

diff --git a/Makefile b/Makefile
index 3bf9f2d4c..826c32d22 100644
--- a/Makefile
+++ b/Makefile
@@ -1005,10 +1005,12 @@ export CC_FLAGS_LTO
 endif
 
 ifdef CONFIG_CFI_CLANG
+ifdef CONFIG_KCFI_CLANG
 CC_FLAGS_CFI	:= -fsanitize=kcfi
 KBUILD_CFLAGS	+= $(CC_FLAGS_CFI)
 export CC_FLAGS_CFI
 endif
+endif
 
 ifdef CONFIG_DEBUG_FORCE_FUNCTION_ALIGN_64B
 KBUILD_CFLAGS += -falign-functions=64
diff --git a/arch/Kconfig b/arch/Kconfig
index e959abf96..45c1ddd0c 100644
--- a/arch/Kconfig
+++ b/arch/Kconfig
@@ -762,10 +762,16 @@ config ARCH_SUPPORTS_CFI_CLANG
 config ARCH_USES_CFI_TRAPS
 	bool
 
+config KCFI_CLANG
+	bool "Use Clang's Kernel Control Flow Integrity (KCFI)"
+	depends on $(cc-option,-fsanitize=kcfi)
+	help
+	  This option is Clang's Kernel Control Flow Integrity checking
+
 config CFI_CLANG
 	bool "Use Clang's Control Flow Integrity (CFI)"
 	depends on ARCH_SUPPORTS_CFI_CLANG
-	depends on $(cc-option,-fsanitize=kcfi)
+	depends on GCC_PLUGINS || KCFI_CLANG
 	help
 	  This option enables Clangâ€™s forward-edge Control Flow Integrity
 	  (CFI) checking, where the compiler injects a runtime check to each
diff --git a/arch/x86/entry/Makefile b/arch/x86/entry/Makefile
index ca2fe1869..faf2e5a87 100644
--- a/arch/x86/entry/Makefile
+++ b/arch/x86/entry/Makefile
@@ -21,3 +21,5 @@ obj-$(CONFIG_PREEMPTION)	+= thunk_$(BITS).o
 obj-$(CONFIG_IA32_EMULATION)	+= entry_64_compat.o syscall_32.o
 obj-$(CONFIG_X86_X32_ABI)	+= syscall_x32.o
 
+CFLAGS_REMOVE_syscall_32.o += -fplugin-arg-rap_plugin-hash=abs-finish
+CFLAGS_REMOVE_syscall_64.o += -fplugin-arg-rap_plugin-hash=abs-finish
diff --git a/arch/x86/include/asm/linkage.h b/arch/x86/include/asm/linkage.h
index 3a0282a6a..378f1f581 100644
--- a/arch/x86/include/asm/linkage.h
+++ b/arch/x86/include/asm/linkage.h
@@ -58,6 +58,14 @@
 	.long __kcfi_typeid_##name ASM_NL			\
 	SYM_FUNC_END(__cfi_##name)
 
+#define __RAP_TYPE(name)					\
+	SYM_START(__cfi_##name, SYM_L_LOCAL, SYM_A_NONE)	\
+	.fill 2, 1, 0xcc ASM_NL				\
+	.byte 0xb8 ASM_NL					\
+	.long __rap_hash_##name ASM_NL			\
+	.fill 2, 1, 0xcc ASM_NL				\
+	SYM_FUNC_END(__cfi_##name)
+
 /* SYM_TYPED_FUNC_START -- use for indirectly called globals, w/ CFI type */
 #define SYM_TYPED_FUNC_START(name)				\
 	SYM_TYPED_START(name, SYM_L_GLOBAL, SYM_A_ALIGN)	\
diff --git a/arch/x86/include/asm/text-patching.h b/arch/x86/include/asm/text-patching.h
index 85b85a275..71814bf4f 100644
--- a/arch/x86/include/asm/text-patching.h
+++ b/arch/x86/include/asm/text-patching.h
@@ -52,6 +52,10 @@ extern void text_poke_bp(void *addr, const void *opcode, size_t len, const void
 extern void text_poke_queue(void *addr, const void *opcode, size_t len, const void *emulate);
 extern void text_poke_finish(void);
 
+#ifdef CONFIG_PAX_RAP
+extern void *memcpy_alt(void *addr, const void *opcode, size_t len);
+#endif
+
 #define INT3_INSN_SIZE		1
 #define INT3_INSN_OPCODE	0xCC
 
diff --git a/arch/x86/include/asm/vermagic.h b/arch/x86/include/asm/vermagic.h
index 75884d2cd..266f5ce89 100644
--- a/arch/x86/include/asm/vermagic.h
+++ b/arch/x86/include/asm/vermagic.h
@@ -5,6 +5,7 @@
 
 #ifdef CONFIG_X86_64
 /* X86_64 does not define MODULE_PROC_FAMILY */
+#define MODULE_PROC_FAMILY ""
 #elif defined CONFIG_M486SX
 #define MODULE_PROC_FAMILY "486SX "
 #elif defined CONFIG_M486
@@ -59,10 +60,12 @@
 #error unknown processor family
 #endif
 
-#ifdef CONFIG_X86_32
-# define MODULE_ARCH_VERMAGIC MODULE_PROC_FAMILY
+#ifdef CONFIG_PAX_RAP
+#define MODULE_PAX_RAP "RAP "
 #else
-# define MODULE_ARCH_VERMAGIC ""
+#define MODULE_PAX_RAP ""
 #endif
 
+#define MODULE_ARCH_VERMAGIC MODULE_PROC_FAMILY MODULE_PAX_RAP
+
 #endif /* _ASM_VERMAGIC_H */
diff --git a/arch/x86/kernel/alternative.c b/arch/x86/kernel/alternative.c
index 69f85e274..291d31fd8 100644
--- a/arch/x86/kernel/alternative.c
+++ b/arch/x86/kernel/alternative.c
@@ -1240,6 +1240,13 @@ void *text_poke(void *addr, const void *opcode, size_t len)
 	return __text_poke(text_poke_memcpy, addr, opcode, len);
 }
 
+#ifdef CONFIG_PAX_RAP
+void *memcpy_alt(void *addr, const void *opcode, size_t len)
+{
+    return memcpy(addr, opcode, len);
+}
+#endif
+
 /**
  * text_poke_kgdb - Update instructions on a live kernel by kgdb
  * @addr: address to modify
diff --git a/arch/x86/kernel/cpu/vmware.c b/arch/x86/kernel/cpu/vmware.c
index b67e7bee1..27a83f41c 100644
--- a/arch/x86/kernel/cpu/vmware.c
+++ b/arch/x86/kernel/cpu/vmware.c
@@ -348,10 +348,17 @@ static __init int activate_jump_labels(void)
 }
 arch_initcall(activate_jump_labels);
 
+/*
+ * No need for any "IO delay" on VMware hypervisor
+ */
+static void vmware_io_delay(void)
+{
+}
+
 static void __init vmware_paravirt_ops_setup(void)
 {
 	pv_info.name = "VMware hypervisor";
-	pv_ops.cpu.io_delay = paravirt_nop;
+	pv_ops.cpu.io_delay = vmware_io_delay;
 
 	if (vmware_tsc_khz == 0)
 		return;
diff --git a/arch/x86/kernel/module.c b/arch/x86/kernel/module.c
index c032edcd3..e41af9f86 100644
--- a/arch/x86/kernel/module.c
+++ b/arch/x86/kernel/module.c
@@ -227,7 +227,11 @@ int apply_relocate_add(Elf64_Shdr *sechdrs,
 {
 	int ret;
 	bool early = me->state == MODULE_STATE_UNFORMED;
-	void *(*write)(void *, const void *, size_t) = memcpy;
+#ifdef CONFIG_PAX_RAP
+    void *(*write)(void *, const void *, size_t) = memcpy_alt;
+#else
+    void *(*write)(void *, const void *, size_t) = memcpy;
+#endif
 
 	if (!early) {
 		write = text_poke;
diff --git a/arch/x86/kernel/paravirt.c b/arch/x86/kernel/paravirt.c
index 7ca2d46c0..e0129c791 100644
--- a/arch/x86/kernel/paravirt.c
+++ b/arch/x86/kernel/paravirt.c
@@ -262,6 +262,10 @@ struct pv_info pv_info = {
 /* 64-bit pagetable entries */
 #define PTE_IDENT	__PV_IS_CALLEE_SAVE(_paravirt_ident_64)
 
+void tlb_remove_page_wrapper(struct mmu_gather *tlb, void *table) {
+	tlb_remove_page(tlb, (struct page *)table);
+}
+
 struct paravirt_patch_template pv_ops = {
 	/* Cpu ops. */
 	.cpu.io_delay		= native_io_delay,
@@ -316,8 +320,7 @@ struct paravirt_patch_template pv_ops = {
 	.mmu.flush_tlb_kernel	= native_flush_tlb_global,
 	.mmu.flush_tlb_one_user	= native_flush_tlb_one_user,
 	.mmu.flush_tlb_multi	= native_flush_tlb_multi,
-	.mmu.tlb_remove_table	=
-			(void (*)(struct mmu_gather *, void *))tlb_remove_page,
+	.mmu.tlb_remove_table	= tlb_remove_page_wrapper,
 
 	.mmu.exit_mmap		= paravirt_nop,
 	.mmu.notify_page_enc_status_changed	= paravirt_nop,
diff --git a/arch/x86/kernel/traps.c b/arch/x86/kernel/traps.c
index c0a5a4f22..5d88ced16 100644
--- a/arch/x86/kernel/traps.c
+++ b/arch/x86/kernel/traps.c
@@ -121,6 +121,10 @@ do_trap_no_signal(struct task_struct *tsk, int trapnr, const char *str,
 
 		tsk->thread.error_code = error_code;
 		tsk->thread.trap_nr = trapnr;
+#ifdef CONFIG_PAX_RAP
+		if (trapnr == X86_TRAP_UD)
+			str = "PAX: overwritten function pointer or return address detected";
+#endif
 		die(str, regs, error_code);
 	} else {
 		if (fixup_vdso_exception(regs, trapnr, error_code, 0))
diff --git a/arch/x86/tools/relocs.c b/arch/x86/tools/relocs.c
index 9a5b101c4..f437a880b 100644
--- a/arch/x86/tools/relocs.c
+++ b/arch/x86/tools/relocs.c
@@ -57,6 +57,7 @@ static const char * const sym_regex_kernel[S_NSYMTYPES] = {
 	"xen_save_fl_direct_reloc$|"
 	"VDSO|"
 	"__kcfi_typeid_|"
+	"__rap_hash_|"
 	"__crc_)",
 
 /*
diff --git a/drivers/block/floppy.c b/drivers/block/floppy.c
index 487840e35..146883d67 100644
--- a/drivers/block/floppy.c
+++ b/drivers/block/floppy.c
@@ -530,14 +530,13 @@ static struct format_descr format_req;
 static char *floppy_track_buffer;
 static int max_buffer_sectors;
 
-typedef void (*done_f)(int);
 static const struct cont_t {
 	void (*interrupt)(void);
 				/* this is called after the interrupt of the
 				 * main command */
 	void (*redo)(void);	/* this is called to retry the operation */
 	void (*error)(void);	/* this is called to tally an error */
-	done_f done;		/* this is called to say if the operation has
+	void (*done)(int);	/* this is called to say if the operation has
 				 * succeeded/failed */
 } *cont;
 
@@ -985,6 +984,10 @@ static void empty(void)
 {
 }
 
+static void empty_done(int)
+{
+}
+
 static void (*floppy_work_fn)(void);
 
 static void floppy_work_workfn(struct work_struct *work)
@@ -1998,14 +2001,14 @@ static const struct cont_t wakeup_cont = {
 	.interrupt	= empty,
 	.redo		= do_wakeup,
 	.error		= empty,
-	.done		= (done_f)empty
+	.done		= empty_done
 };
 
 static const struct cont_t intr_cont = {
 	.interrupt	= empty,
 	.redo		= process_fd_request,
 	.error		= empty,
-	.done		= (done_f)empty
+	.done		= empty_done
 };
 
 /* schedules handler, waiting for completion. May be interrupted, will then
diff --git a/drivers/char/tpm/tpm-chip.c b/drivers/char/tpm/tpm-chip.c
index c0759d49f..64395bfef 100644
--- a/drivers/char/tpm/tpm-chip.c
+++ b/drivers/char/tpm/tpm-chip.c
@@ -373,6 +373,11 @@ struct tpm_chip *tpm_chip_alloc(struct device *pdev,
 }
 EXPORT_SYMBOL_GPL(tpm_chip_alloc);
 
+static void tpm_put_device(void *dev)
+{
+	put_device(dev);
+}
+
 /**
  * tpmm_chip_alloc() - allocate a new struct tpm_chip instance
  * @pdev: parent device to which the chip is associated
@@ -390,9 +395,7 @@ struct tpm_chip *tpmm_chip_alloc(struct device *pdev,
 	if (IS_ERR(chip))
 		return chip;
 
-	rc = devm_add_action_or_reset(pdev,
-				      (void (*)(void *)) put_device,
-				      &chip->dev);
+	rc = devm_add_action_or_reset(pdev, tpm_put_device, &chip->dev);
 	if (rc)
 		return ERR_PTR(rc);
 
diff --git a/drivers/firmware/dmi-id.c b/drivers/firmware/dmi-id.c
index 940ddf916..77a8d43e6 100644
--- a/drivers/firmware/dmi-id.c
+++ b/drivers/firmware/dmi-id.c
@@ -169,9 +169,14 @@ static int dmi_dev_uevent(struct device *dev, struct kobj_uevent_env *env)
 	return 0;
 }
 
+static void dmi_dev_release(struct device *dev)
+{
+	kfree(dev);
+}
+
 static struct class dmi_class = {
 	.name = "dmi",
-	.dev_release = (void(*)(struct device *)) kfree,
+	.dev_release = dmi_dev_release,
 	.dev_uevent = dmi_dev_uevent,
 };
 
diff --git a/drivers/net/ethernet/brocade/bna/bfa_cs.h b/drivers/net/ethernet/brocade/bna/bfa_cs.h
index 8f0ac7b99..dffc8837b 100644
--- a/drivers/net/ethernet/brocade/bna/bfa_cs.h
+++ b/drivers/net/ethernet/brocade/bna/bfa_cs.h
@@ -26,10 +26,19 @@ struct bfa_sm_table {
 	int		state;	/*!< state machine encoding	*/
 	char		*name;	/*!< state name for display	*/
 };
-#define BFA_SM(_sm)		((bfa_sm_t)(_sm))
+#define BFA_SM(_sm)		(_sm)
+
+#define bfa_sm_set_state(_sm, _state)	((_sm)->sm = (_state))
+#define bfa_sm_cmp_state(_sm, _state)	((_sm)->sm == (_state))
 
 /* State machine with entry actions. */
-typedef void (*bfa_fsm_t)(void *fsm, int event);
+struct bfa_ioc;
+enum ioc_event;
+struct bfa_iocpf;
+enum iocpf_event;
+
+typedef void (*bfa_fsm_ioc_t)(struct bfa_ioc *fsm, enum ioc_event event);
+typedef void (*bfa_fsm_iocpf_t)(struct bfa_iocpf *fsm, enum iocpf_event event);
 
 /* oc - object class eg. bfa_ioc
  * st - state, eg. reset
@@ -41,16 +50,37 @@ typedef void (*bfa_fsm_t)(void *fsm, int event);
 	static void oc ## _sm_ ## st ## _entry(otype * fsm)
 
 #define bfa_fsm_set_state(_fsm, _state) do {				\
-	(_fsm)->fsm = (bfa_fsm_t)(_state);				\
+	(_fsm)->fsm = (_state);						\
 	_state ## _entry(_fsm);						\
 } while (0)
 
 #define bfa_fsm_send_event(_fsm, _event)	((_fsm)->fsm((_fsm), (_event)))
-#define bfa_fsm_cmp_state(_fsm, _state)					\
-	((_fsm)->fsm == (bfa_fsm_t)(_state))
+#define bfa_fsm_cmp_state(_fsm, _state)		((_fsm)->fsm == (_state))
+
+/* For converting from state machine function to state encoding. */
+struct iocpf_sm_table {
+	bfa_fsm_iocpf_t	sm;	/*!< state machine function	*/
+	int		state;	/*!< state machine encoding	*/
+	char		*name;	/*!< state name for display	*/
+};
+struct ioc_sm_table {
+	bfa_fsm_ioc_t	sm;	/*!< state machine function	*/
+	int		state;	/*!< state machine encoding	*/
+	char		*name;	/*!< state name for display	*/
+};
+
+static inline int
+iocpf_sm_to_state(const struct iocpf_sm_table *smt, bfa_fsm_iocpf_t sm)
+{
+	int	i = 0;
+
+	while (smt[i].sm && smt[i].sm != sm)
+		i++;
+	return smt[i].state;
+}
 
 static inline int
-bfa_sm_to_state(const struct bfa_sm_table *smt, bfa_sm_t sm)
+ioc_sm_to_state(const struct ioc_sm_table *smt, bfa_fsm_ioc_t sm)
 {
 	int	i = 0;
 
diff --git a/drivers/net/ethernet/brocade/bna/bfa_ioc.c b/drivers/net/ethernet/brocade/bna/bfa_ioc.c
index cd933817a..d2fb975f9 100644
--- a/drivers/net/ethernet/brocade/bna/bfa_ioc.c
+++ b/drivers/net/ethernet/brocade/bna/bfa_ioc.c
@@ -114,7 +114,7 @@ bfa_fsm_state_decl(bfa_ioc, disabling, struct bfa_ioc, enum ioc_event);
 bfa_fsm_state_decl(bfa_ioc, disabled, struct bfa_ioc, enum ioc_event);
 bfa_fsm_state_decl(bfa_ioc, hwfail, struct bfa_ioc, enum ioc_event);
 
-static struct bfa_sm_table ioc_sm_table[] = {
+static struct ioc_sm_table ioc_sm_table[] = {
 	{BFA_SM(bfa_ioc_sm_uninit), BFA_IOC_UNINIT},
 	{BFA_SM(bfa_ioc_sm_reset), BFA_IOC_RESET},
 	{BFA_SM(bfa_ioc_sm_enabling), BFA_IOC_ENABLING},
@@ -183,7 +183,7 @@ bfa_fsm_state_decl(bfa_iocpf, disabling_sync, struct bfa_iocpf,
 						enum iocpf_event);
 bfa_fsm_state_decl(bfa_iocpf, disabled, struct bfa_iocpf, enum iocpf_event);
 
-static struct bfa_sm_table iocpf_sm_table[] = {
+static struct iocpf_sm_table iocpf_sm_table[] = {
 	{BFA_SM(bfa_iocpf_sm_reset), BFA_IOCPF_RESET},
 	{BFA_SM(bfa_iocpf_sm_fwcheck), BFA_IOCPF_FWMISMATCH},
 	{BFA_SM(bfa_iocpf_sm_mismatch), BFA_IOCPF_FWMISMATCH},
@@ -2860,12 +2860,12 @@ static enum bfa_ioc_state
 bfa_ioc_get_state(struct bfa_ioc *ioc)
 {
 	enum bfa_iocpf_state iocpf_st;
-	enum bfa_ioc_state ioc_st = bfa_sm_to_state(ioc_sm_table, ioc->fsm);
+	enum bfa_ioc_state ioc_st = ioc_sm_to_state(ioc_sm_table, ioc->fsm);
 
 	if (ioc_st == BFA_IOC_ENABLING ||
 		ioc_st == BFA_IOC_FAIL || ioc_st == BFA_IOC_INITFAIL) {
 
-		iocpf_st = bfa_sm_to_state(iocpf_sm_table, ioc->iocpf.fsm);
+		iocpf_st = iocpf_sm_to_state(iocpf_sm_table, ioc->iocpf.fsm);
 
 		switch (iocpf_st) {
 		case BFA_IOCPF_SEMWAIT:
@@ -2983,7 +2983,7 @@ bfa_nw_iocpf_timeout(struct bfa_ioc *ioc)
 {
 	enum bfa_iocpf_state iocpf_st;
 
-	iocpf_st = bfa_sm_to_state(iocpf_sm_table, ioc->iocpf.fsm);
+	iocpf_st = iocpf_sm_to_state(iocpf_sm_table, ioc->iocpf.fsm);
 
 	if (iocpf_st == BFA_IOCPF_HWINIT)
 		bfa_ioc_poll_fwinit(ioc);
diff --git a/drivers/net/ethernet/brocade/bna/bfa_ioc.h b/drivers/net/ethernet/brocade/bna/bfa_ioc.h
index edd0ed5b5..1b93441ae 100644
--- a/drivers/net/ethernet/brocade/bna/bfa_ioc.h
+++ b/drivers/net/ethernet/brocade/bna/bfa_ioc.h
@@ -148,7 +148,7 @@ struct bfa_ioc_notify {
 } while (0)
 
 struct bfa_iocpf {
-	bfa_fsm_t		fsm;
+	bfa_fsm_iocpf_t		fsm;
 	struct bfa_ioc		*ioc;
 	bool			fw_mismatch_notified;
 	bool			auto_recover;
@@ -156,7 +156,7 @@ struct bfa_iocpf {
 };
 
 struct bfa_ioc {
-	bfa_fsm_t		fsm;
+	bfa_fsm_ioc_t		fsm;
 	struct bfa		*bfa;
 	struct bfa_pcidev	pcidev;
 	struct timer_list	ioc_timer;
diff --git a/drivers/net/ethernet/brocade/bna/bfa_msgq.h b/drivers/net/ethernet/brocade/bna/bfa_msgq.h
index 75343b535..ad775b035 100644
--- a/drivers/net/ethernet/brocade/bna/bfa_msgq.h
+++ b/drivers/net/ethernet/brocade/bna/bfa_msgq.h
@@ -55,8 +55,10 @@ enum bfa_msgq_cmdq_flags {
 	BFA_MSGQ_CMDQ_F_DB_UPDATE	= 1,
 };
 
+enum cmdq_event;
+
 struct bfa_msgq_cmdq {
-	bfa_fsm_t			fsm;
+	void (*fsm)(struct bfa_msgq_cmdq *, enum cmdq_event);
 	enum bfa_msgq_cmdq_flags flags;
 
 	u16			producer_index;
@@ -81,8 +83,10 @@ enum bfa_msgq_rspq_flags {
 
 typedef void (*bfa_msgq_mcfunc_t)(void *cbarg, struct bfi_msgq_mhdr *mhdr);
 
+enum rspq_event;
+
 struct bfa_msgq_rspq {
-	bfa_fsm_t			fsm;
+	void (*fsm)(struct bfa_msgq_rspq *, enum rspq_event);
 	enum bfa_msgq_rspq_flags flags;
 
 	u16			producer_index;
diff --git a/drivers/net/ethernet/brocade/bna/bna_enet.c b/drivers/net/ethernet/brocade/bna/bna_enet.c
index a2c983f56..883de0ac8 100644
--- a/drivers/net/ethernet/brocade/bna/bna_enet.c
+++ b/drivers/net/ethernet/brocade/bna/bna_enet.c
@@ -1257,7 +1257,7 @@ bna_enet_mtu_get(struct bna_enet *enet)
 void
 bna_enet_enable(struct bna_enet *enet)
 {
-	if (enet->fsm != (bfa_sm_t)bna_enet_sm_stopped)
+	if (enet->fsm != bna_enet_sm_stopped)
 		return;
 
 	enet->flags |= BNA_ENET_F_ENABLED;
@@ -1751,12 +1751,12 @@ bna_ioceth_uninit(struct bna_ioceth *ioceth)
 void
 bna_ioceth_enable(struct bna_ioceth *ioceth)
 {
-	if (ioceth->fsm == (bfa_fsm_t)bna_ioceth_sm_ready) {
+	if (ioceth->fsm == bna_ioceth_sm_ready) {
 		bnad_cb_ioceth_ready(ioceth->bna->bnad);
 		return;
 	}
 
-	if (ioceth->fsm == (bfa_fsm_t)bna_ioceth_sm_stopped)
+	if (ioceth->fsm == bna_ioceth_sm_stopped)
 		bfa_fsm_send_event(ioceth, IOCETH_E_ENABLE);
 }
 
diff --git a/drivers/net/ethernet/brocade/bna/bna_tx_rx.c b/drivers/net/ethernet/brocade/bna/bna_tx_rx.c
index 2623a0da4..c05dc7a1c 100644
--- a/drivers/net/ethernet/brocade/bna/bna_tx_rx.c
+++ b/drivers/net/ethernet/brocade/bna/bna_tx_rx.c
@@ -1956,7 +1956,7 @@ static void
 bna_rx_stop(struct bna_rx *rx)
 {
 	rx->rx_flags &= ~BNA_RX_F_ENET_STARTED;
-	if (rx->fsm == (bfa_fsm_t) bna_rx_sm_stopped)
+	if (rx->fsm == bna_rx_sm_stopped)
 		bna_rx_mod_cb_rx_stopped(&rx->bna->rx_mod, rx);
 	else {
 		rx->stop_cbfn = bna_rx_mod_cb_rx_stopped;
@@ -2535,7 +2535,7 @@ bna_rx_destroy(struct bna_rx *rx)
 void
 bna_rx_enable(struct bna_rx *rx)
 {
-	if (rx->fsm != (bfa_sm_t)bna_rx_sm_stopped)
+	if (rx->fsm != bna_rx_sm_stopped)
 		return;
 
 	rx->rx_flags |= BNA_RX_F_ENABLED;
@@ -3523,7 +3523,7 @@ bna_tx_destroy(struct bna_tx *tx)
 void
 bna_tx_enable(struct bna_tx *tx)
 {
-	if (tx->fsm != (bfa_sm_t)bna_tx_sm_stopped)
+	if (tx->fsm != bna_tx_sm_stopped)
 		return;
 
 	tx->flags |= BNA_TX_F_ENABLED;
diff --git a/drivers/net/ethernet/brocade/bna/bna_types.h b/drivers/net/ethernet/brocade/bna/bna_types.h
index 666b6922e..94261bb24 100644
--- a/drivers/net/ethernet/brocade/bna/bna_types.h
+++ b/drivers/net/ethernet/brocade/bna/bna_types.h
@@ -312,8 +312,10 @@ struct bna_attr {
 
 /* IOCEth */
 
+enum bna_ioceth_event;
+
 struct bna_ioceth {
-	bfa_fsm_t		fsm;
+	void (*fsm)(struct bna_ioceth *, enum bna_ioceth_event);
 	struct bfa_ioc ioc;
 
 	struct bna_attr attr;
@@ -334,8 +336,10 @@ struct bna_pause_config {
 	enum bna_status rx_pause;
 };
 
+enum bna_enet_event;
+
 struct bna_enet {
-	bfa_fsm_t		fsm;
+	void (*fsm)(struct bna_enet *, enum bna_enet_event);
 	enum bna_enet_flags flags;
 
 	enum bna_enet_type type;
@@ -360,8 +364,10 @@ struct bna_enet {
 
 /* Ethport */
 
+enum bna_ethport_event;
+
 struct bna_ethport {
-	bfa_fsm_t		fsm;
+	void (*fsm)(struct bna_ethport *, enum bna_ethport_event);
 	enum bna_ethport_flags flags;
 
 	enum bna_link_status link_status;
@@ -454,13 +460,15 @@ struct bna_txq {
 };
 
 /* Tx object */
+enum bna_tx_event;
+
 struct bna_tx {
 	/* This should be the first one */
 	struct list_head			qe;
 	int			rid;
 	int			hw_id;
 
-	bfa_fsm_t		fsm;
+	void (*fsm)(struct bna_tx *, enum bna_tx_event);
 	enum bna_tx_flags flags;
 
 	enum bna_tx_type type;
@@ -698,8 +706,10 @@ struct bna_rxp {
 };
 
 /* RxF structure (hardware Rx Function) */
+enum bna_rxf_event;
+
 struct bna_rxf {
-	bfa_fsm_t		fsm;
+	void (*fsm)(struct bna_rxf *, enum bna_rxf_event);
 
 	struct bfa_msgq_cmd_entry msgq_cmd;
 	union {
@@ -769,13 +779,15 @@ struct bna_rxf {
 };
 
 /* Rx object */
+enum bna_rx_event;
+
 struct bna_rx {
 	/* This should be the first one */
 	struct list_head			qe;
 	int			rid;
 	int			hw_id;
 
-	bfa_fsm_t		fsm;
+	void (*fsm)(struct bna_rx *, enum bna_rx_event);
 
 	enum bna_rx_type type;
 
diff --git a/drivers/net/ethernet/brocade/bna/bnad.c b/drivers/net/ethernet/brocade/bna/bnad.c
index d6d90f972..cb8e17ddf 100644
--- a/drivers/net/ethernet/brocade/bna/bnad.c
+++ b/drivers/net/ethernet/brocade/bna/bnad.c
@@ -1092,8 +1092,9 @@ bnad_cb_tx_resume(struct bnad *bnad, struct bna_tx *tx)
  * Free all TxQs buffers and then notify TX_E_CLEANUP_DONE to Tx fsm.
  */
 static void
-bnad_tx_cleanup(struct delayed_work *work)
+bnad_tx_cleanup(struct work_struct *_work)
 {
+	struct delayed_work *work = (struct delayed_work *)_work;
 	struct bnad_tx_info *tx_info =
 		container_of(work, struct bnad_tx_info, tx_cleanup_work);
 	struct bnad *bnad = NULL;
@@ -1171,7 +1172,7 @@ bnad_cb_rx_stall(struct bnad *bnad, struct bna_rx *rx)
  * Free all RxQs buffers and then notify RX_E_CLEANUP_DONE to Rx fsm.
  */
 static void
-bnad_rx_cleanup(void *work)
+bnad_rx_cleanup(struct work_struct *work)
 {
 	struct bnad_rx_info *rx_info =
 		container_of(work, struct bnad_rx_info, rx_cleanup_work);
@@ -1992,8 +1993,7 @@ bnad_setup_tx(struct bnad *bnad, u32 tx_id)
 	}
 	tx_info->tx = tx;
 
-	INIT_DELAYED_WORK(&tx_info->tx_cleanup_work,
-			(work_func_t)bnad_tx_cleanup);
+	INIT_DELAYED_WORK(&tx_info->tx_cleanup_work, bnad_tx_cleanup);
 
 	/* Register ISR for the Tx object */
 	if (intr_info->intr_type == BNA_INTR_T_MSIX) {
@@ -2249,8 +2249,7 @@ bnad_setup_rx(struct bnad *bnad, u32 rx_id)
 	rx_info->rx = rx;
 	spin_unlock_irqrestore(&bnad->bna_lock, flags);
 
-	INIT_WORK(&rx_info->rx_cleanup_work,
-			(work_func_t)(bnad_rx_cleanup));
+	INIT_WORK(&rx_info->rx_cleanup_work, bnad_rx_cleanup);
 
 	/*
 	 * Init NAPI, so that state is set to NAPI_STATE_SCHED,
diff --git a/drivers/scsi/bfa/bfa.h b/drivers/scsi/bfa/bfa.h
index f30fe324e..f4a755651 100644
--- a/drivers/scsi/bfa/bfa.h
+++ b/drivers/scsi/bfa/bfa.h
@@ -215,8 +215,10 @@ struct bfa_faa_args_s {
 	bfa_boolean_t		busy;
 };
 
+enum iocfc_event;
+
 struct bfa_iocfc_s {
-	bfa_fsm_t		fsm;
+	void (*fsm)(struct bfa_iocfc_s *, enum iocfc_event);
 	struct bfa_s		*bfa;
 	struct bfa_iocfc_cfg_s	cfg;
 	u32		req_cq_pi[BFI_IOC_MAX_CQS];
diff --git a/drivers/scsi/bfa/bfa_cs.h b/drivers/scsi/bfa/bfa_cs.h
index 6b606bf58..aac8ad1f5 100644
--- a/drivers/scsi/bfa/bfa_cs.h
+++ b/drivers/scsi/bfa/bfa_cs.h
@@ -176,8 +176,6 @@ bfa_q_is_on_q_func(struct list_head *q, struct list_head *qe)
  * @ BFA state machine interfaces
  */
 
-typedef void (*bfa_sm_t)(void *sm, int event);
-
 /*
  * oc - object class eg. bfa_ioc
  * st - state, eg. reset
@@ -187,20 +185,75 @@ typedef void (*bfa_sm_t)(void *sm, int event);
 #define bfa_sm_state_decl(oc, st, otype, etype)		\
 	static void oc ## _sm_ ## st(otype * fsm, etype event)
 
-#define bfa_sm_set_state(_sm, _state)	((_sm)->sm = (bfa_sm_t)(_state))
+#define bfa_sm_set_state(_sm, _state)	((_sm)->sm = (_state))
 #define bfa_sm_send_event(_sm, _event)	((_sm)->sm((_sm), (_event)))
 #define bfa_sm_get_state(_sm)		((_sm)->sm)
-#define bfa_sm_cmp_state(_sm, _state)	((_sm)->sm == (bfa_sm_t)(_state))
+#define bfa_sm_cmp_state(_sm, _state)	((_sm)->sm == (_state))
 
 /*
  * For converting from state machine function to state encoding.
  */
-struct bfa_sm_table_s {
-	bfa_sm_t	sm;	/*  state machine function	*/
+struct bfa_iocpf_s;
+enum iocpf_event;
+typedef void (*bfa_fsm_iocpf_t)(struct bfa_iocpf_s *, enum iocpf_event);
+
+struct iocpf_sm_table_s {
+	bfa_fsm_iocpf_t sm;	/*  state machine function	*/
+	int		state;	/*  state machine encoding	*/
+	char		*name;	/*  state name for display	*/
+};
+
+struct bfa_ioc_s;
+enum ioc_event;
+typedef void (*bfa_fsm_ioc_t)(struct bfa_ioc_s *, enum ioc_event);
+
+struct ioc_sm_table_s {
+	bfa_fsm_ioc_t sm;	/*  state machine function	*/
 	int		state;	/*  state machine encoding	*/
 	char		*name;	/*  state name for display	*/
 };
-#define BFA_SM(_sm)	((bfa_sm_t)(_sm))
+
+struct bfa_fcs_rport_s;
+enum rport_event;
+typedef void(*bfa_fcs_rport_t)(struct bfa_fcs_rport_s *, enum rport_event);
+
+struct rport_sm_table_s {
+	bfa_fcs_rport_t sm;	/*  state machine function	*/
+	int		state;	/*  state machine encoding	*/
+	char		*name;	/*  state name for display	*/
+};
+
+struct bfa_fcs_vport_s;
+enum bfa_fcs_vport_event;
+typedef void(*bfa_fcs_vport_t)(struct bfa_fcs_vport_s *, enum bfa_fcs_vport_event);
+
+struct vport_sm_table_s {
+	bfa_fcs_vport_t sm;	/*  state machine function	*/
+	int		state;	/*  state machine encoding	*/
+	char		*name;	/*  state name for display	*/
+};
+
+struct bfa_fcs_itnim_s;
+enum bfa_fcs_itnim_event;
+typedef void(*bfa_fcs_itnim_t)(struct bfa_fcs_itnim_s *, enum bfa_fcs_itnim_event);
+
+struct itnim_sm_table_s {
+	bfa_fcs_itnim_t sm;	/*  state machine function	*/
+	int		state;	/*  state machine encoding	*/
+	char		*name;	/*  state name for display	*/
+};
+
+struct bfa_fcport_s;
+enum bfa_fcport_sm_event;
+typedef void(*bfa_fcport_t)(struct bfa_fcport_s *, enum bfa_fcport_sm_event);
+
+struct fcport_sm_table_s {
+	bfa_fcport_t sm;	/*  state machine function	*/
+	int		state;	/*  state machine encoding	*/
+	char		*name;	/*  state name for display	*/
+};
+
+#define BFA_SM(_sm)	(_sm)
 
 /*
  * State machine with entry actions.
@@ -218,17 +271,66 @@ typedef void (*bfa_fsm_t)(void *fsm, int event);
 	static void oc ## _sm_ ## st ## _entry(otype * fsm)
 
 #define bfa_fsm_set_state(_fsm, _state) do {	\
-	(_fsm)->fsm = (bfa_fsm_t)(_state);      \
+	(_fsm)->fsm = (_state);      \
 	_state ## _entry(_fsm);      \
 } while (0)
 
 #define bfa_fsm_send_event(_fsm, _event)	((_fsm)->fsm((_fsm), (_event)))
 #define bfa_fsm_get_state(_fsm)			((_fsm)->fsm)
-#define bfa_fsm_cmp_state(_fsm, _state)		\
-	((_fsm)->fsm == (bfa_fsm_t)(_state))
+#define bfa_fsm_cmp_state(_fsm, _state)		((_fsm)->fsm == (_state))
+
+static inline int
+iocpf_sm_to_state(struct iocpf_sm_table_s *smt, bfa_fsm_iocpf_t sm)
+{
+	int	i = 0;
+
+	while (smt[i].sm && smt[i].sm != sm)
+		i++;
+	return smt[i].state;
+}
+
+static inline int
+ioc_sm_to_state(struct ioc_sm_table_s *smt, bfa_fsm_ioc_t sm)
+{
+	int	i = 0;
+
+	while (smt[i].sm && smt[i].sm != sm)
+		i++;
+	return smt[i].state;
+}
+
+static inline int
+rport_sm_to_state(struct rport_sm_table_s *smt, bfa_fcs_rport_t sm)
+{
+	int	i = 0;
+
+	while (smt[i].sm && smt[i].sm != sm)
+		i++;
+	return smt[i].state;
+}
+
+static inline int
+vport_sm_to_state(struct vport_sm_table_s *smt, bfa_fcs_vport_t sm)
+{
+	int	i = 0;
+
+	while (smt[i].sm && smt[i].sm != sm)
+		i++;
+	return smt[i].state;
+}
+
+static inline int
+itnim_sm_to_state(struct itnim_sm_table_s *smt, bfa_fcs_itnim_t sm)
+{
+	int	i = 0;
+
+	while (smt[i].sm && smt[i].sm != sm)
+		i++;
+	return smt[i].state;
+}
 
 static inline int
-bfa_sm_to_state(struct bfa_sm_table_s *smt, bfa_sm_t sm)
+fcport_sm_to_state(struct fcport_sm_table_s *smt, bfa_fcport_t sm)
 {
 	int	i = 0;
 
diff --git a/drivers/scsi/bfa/bfa_fcpim.h b/drivers/scsi/bfa/bfa_fcpim.h
index 8bf094335..060af3ac4 100644
--- a/drivers/scsi/bfa/bfa_fcpim.h
+++ b/drivers/scsi/bfa/bfa_fcpim.h
@@ -157,9 +157,11 @@ struct bfa_fcp_mod_s {
 /*
  * BFA IO (initiator mode)
  */
+enum bfa_ioim_event;
+
 struct bfa_ioim_s {
 	struct list_head	qe;		/*  queue elememt	*/
-	bfa_sm_t		sm;		/*  BFA ioim state machine */
+	void (*sm)(struct bfa_ioim_s *, enum bfa_ioim_event);/*  BFA ioim state machine */
 	struct bfa_s		*bfa;		/*  BFA module	*/
 	struct bfa_fcpim_s	*fcpim;		/*  parent fcpim module */
 	struct bfa_itnim_s	*itnim;		/*  i-t-n nexus for this IO  */
@@ -189,9 +191,11 @@ struct bfa_ioim_sp_s {
 /*
  * BFA Task management command (initiator mode)
  */
+enum bfa_tskim_event;
+
 struct bfa_tskim_s {
 	struct list_head	qe;
-	bfa_sm_t		sm;
+	void (*sm)(struct bfa_tskim_s *, enum bfa_tskim_event);
 	struct bfa_s		*bfa;	/*  BFA module  */
 	struct bfa_fcpim_s	*fcpim;	/*  parent fcpim module	*/
 	struct bfa_itnim_s	*itnim;	/*  i-t-n nexus for this IO  */
@@ -211,9 +215,11 @@ struct bfa_tskim_s {
 /*
  * BFA i-t-n (initiator mode)
  */
+enum bfa_itnim_event;
+
 struct bfa_itnim_s {
 	struct list_head	qe;	/*  queue element	*/
-	bfa_sm_t		sm;	/*  i-t-n im BFA state machine  */
+	void (*sm)(struct bfa_itnim_s *, enum bfa_itnim_event);/*  i-t-n im BFA state machine  */
 	struct bfa_s		*bfa;	/*  bfa instance	*/
 	struct bfa_rport_s	*rport;	/*  bfa rport	*/
 	void			*ditn;	/*  driver i-t-n structure	*/
diff --git a/drivers/scsi/bfa/bfa_fcs.h b/drivers/scsi/bfa/bfa_fcs.h
index c1baf5cd0..733a2993b 100644
--- a/drivers/scsi/bfa/bfa_fcs.h
+++ b/drivers/scsi/bfa/bfa_fcs.h
@@ -59,8 +59,10 @@ struct bfa_fcs_s;
 #define BFA_FCS_PID_IS_WKA(pid)  ((bfa_ntoh3b(pid) > 0xFFF000) ?  1 : 0)
 #define BFA_FCS_MAX_RPORT_LOGINS 1024
 
+enum vport_ns_event;
+
 struct bfa_fcs_lport_ns_s {
-	bfa_sm_t        sm;		/*  state machine */
+	void (*sm)(struct bfa_fcs_lport_ns_s *, enum vport_ns_event);/*  state machine */
 	struct bfa_timer_s timer;
 	struct bfa_fcs_lport_s *port;	/*  parent port */
 	struct bfa_fcxp_s *fcxp;
@@ -69,18 +71,20 @@ struct bfa_fcs_lport_ns_s {
 	u8	num_rsnn_nn_retries;
 };
 
+enum port_scn_event;
 
 struct bfa_fcs_lport_scn_s {
-	bfa_sm_t        sm;		/*  state machine */
+	void (*sm)(struct bfa_fcs_lport_scn_s *, enum port_scn_event);/*  state machine */
 	struct bfa_timer_s timer;
 	struct bfa_fcs_lport_s *port;	/*  parent port */
 	struct bfa_fcxp_s *fcxp;
 	struct bfa_fcxp_wqe_s fcxp_wqe;
 };
 
+enum port_fdmi_event;
 
 struct bfa_fcs_lport_fdmi_s {
-	bfa_sm_t        sm;		/*  state machine */
+	void (*sm)(struct bfa_fcs_lport_fdmi_s *, enum port_fdmi_event);/*  state machine */
 	struct bfa_timer_s timer;
 	struct bfa_fcs_lport_ms_s *ms;	/*  parent ms */
 	struct bfa_fcxp_s *fcxp;
@@ -89,9 +93,10 @@ struct bfa_fcs_lport_fdmi_s {
 	u8	rsvd[3];
 };
 
+enum port_ms_event;
 
 struct bfa_fcs_lport_ms_s {
-	bfa_sm_t        sm;		/*  state machine */
+	void (*sm)(struct bfa_fcs_lport_ms_s *, enum port_ms_event);/*  state machine */
 	struct bfa_timer_s timer;
 	struct bfa_fcs_lport_s *port;	/*  parent port */
 	struct bfa_fcxp_s *fcxp;
@@ -131,10 +136,11 @@ union bfa_fcs_lport_topo_u {
 	struct bfa_fcs_lport_n2n_s pn2n;
 };
 
+enum bfa_fcs_lport_event;
 
 struct bfa_fcs_lport_s {
 	struct list_head         qe;	/*  used by port/vport */
-	bfa_sm_t               sm;	/*  state machine */
+	void (*sm)(struct bfa_fcs_lport_s *, enum bfa_fcs_lport_event);	/*  state machine */
 	struct bfa_fcs_fabric_s *fabric;	/*  parent fabric */
 	struct bfa_lport_cfg_s  port_cfg;	/*  port configuration */
 	struct bfa_timer_s link_timer;	/*  timer for link offline */
@@ -171,10 +177,11 @@ enum bfa_fcs_fabric_type {
 	BFA_FCS_FABRIC_LOOP = 3,
 };
 
+enum bfa_fcs_fabric_event;
 
 struct bfa_fcs_fabric_s {
 	struct list_head   qe;		/*  queue element */
-	bfa_sm_t	 sm;		/*  state machine */
+	void (*sm)(struct bfa_fcs_fabric_s *, enum bfa_fcs_fabric_event); /*  state machine */
 	struct bfa_fcs_s *fcs;		/*  FCS instance */
 	struct bfa_fcs_lport_s  bport;	/*  base logical port */
 	enum bfa_fcs_fabric_type fab_type; /*  fabric type */
@@ -344,9 +351,11 @@ void            bfa_fcs_lport_scn_process_rscn(struct bfa_fcs_lport_s *port,
 					      struct fchs_s *rx_frame, u32 len);
 void		bfa_fcs_lport_lip_scn_online(bfa_fcs_lport_t *port);
 
+enum bfa_fcs_vport_event;
+
 struct bfa_fcs_vport_s {
 	struct list_head		qe;		/*  queue elem	*/
-	bfa_sm_t		sm;		/*  state machine	*/
+	void (*sm)(struct bfa_fcs_vport_s *, enum bfa_fcs_vport_event);/*  state machine	*/
 	bfa_fcs_lport_t		lport;		/*  logical port	*/
 	struct bfa_timer_s	timer;
 	struct bfad_vport_s	*vport_drv;	/*  Driver private	*/
@@ -398,8 +407,10 @@ struct bfa_fcs_tin_s;
 struct bfa_fcs_iprp_s;
 
 /* Rport Features (RPF) */
+enum rpf_event;
+
 struct bfa_fcs_rpf_s {
-	bfa_sm_t	sm;	/*  state machine */
+	void (*sm)(struct bfa_fcs_rpf_s *, enum rpf_event); /*  state machine */
 	struct bfa_fcs_rport_s *rport;	/*  parent rport */
 	struct bfa_timer_s	timer;	/*  general purpose timer */
 	struct bfa_fcxp_s	*fcxp;	/*  FCXP needed for discarding */
@@ -414,6 +425,8 @@ struct bfa_fcs_rpf_s {
 	 */
 };
 
+enum rport_event;
+
 struct bfa_fcs_rport_s {
 	struct list_head	qe;	/*  used by port/vport */
 	struct bfa_fcs_lport_s *port;	/*  parent FCS port */
@@ -430,7 +443,7 @@ struct bfa_fcs_rport_s {
 	wwn_t	pwwn;	/*  port wwn of rport */
 	wwn_t	nwwn;	/*  node wwn of rport */
 	struct bfa_rport_symname_s psym_name; /*  port symbolic name  */
-	bfa_sm_t	sm;		/*  state machine */
+	void (*sm)(struct bfa_fcs_rport_s *, enum rport_event); /*  state machine */
 	struct bfa_timer_s timer;	/*  general purpose timer */
 	struct bfa_fcs_itnim_s *itnim;	/*  ITN initiator mode role */
 	struct bfa_fcs_tin_s *tin;	/*  ITN initiator mode role */
@@ -491,9 +504,10 @@ void  bfa_fcs_rpf_rport_offline(struct bfa_fcs_rport_s *rport);
  * forward declarations
  */
 struct bfad_itnim_s;
+enum bfa_fcs_itnim_event;
 
 struct bfa_fcs_itnim_s {
-	bfa_sm_t		sm;		/*  state machine */
+	void (*sm)(struct bfa_fcs_itnim_s *, enum bfa_fcs_itnim_event);/*  state machine */
 	struct bfa_fcs_rport_s	*rport;		/*  parent remote rport  */
 	struct bfad_itnim_s	*itnim_drv;	/*  driver peer instance */
 	struct bfa_fcs_s	*fcs;		/*  fcs instance	*/
diff --git a/drivers/scsi/bfa/bfa_fcs_fcpim.c b/drivers/scsi/bfa/bfa_fcs_fcpim.c
index c7de62bae..27ccaf6a4 100644
--- a/drivers/scsi/bfa/bfa_fcs_fcpim.c
+++ b/drivers/scsi/bfa/bfa_fcs_fcpim.c
@@ -52,7 +52,7 @@ static void	bfa_fcs_itnim_sm_hcb_offline(struct bfa_fcs_itnim_s *itnim,
 static void	bfa_fcs_itnim_sm_initiator(struct bfa_fcs_itnim_s *itnim,
 					   enum bfa_fcs_itnim_event event);
 
-static struct bfa_sm_table_s itnim_sm_table[] = {
+static struct itnim_sm_table_s itnim_sm_table[] = {
 	{BFA_SM(bfa_fcs_itnim_sm_offline), BFA_ITNIM_OFFLINE},
 	{BFA_SM(bfa_fcs_itnim_sm_prli_send), BFA_ITNIM_PRLI_SEND},
 	{BFA_SM(bfa_fcs_itnim_sm_prli), BFA_ITNIM_PRLI_SENT},
@@ -665,7 +665,7 @@ bfa_status_t
 bfa_fcs_itnim_get_online_state(struct bfa_fcs_itnim_s *itnim)
 {
 	bfa_trc(itnim->fcs, itnim->rport->pid);
-	switch (bfa_sm_to_state(itnim_sm_table, itnim->sm)) {
+	switch (itnim_sm_to_state(itnim_sm_table, itnim->sm)) {
 	case BFA_ITNIM_ONLINE:
 	case BFA_ITNIM_INITIATIOR:
 		return BFA_STATUS_OK;
@@ -765,7 +765,7 @@ bfa_fcs_itnim_attr_get(struct bfa_fcs_lport_s *port, wwn_t rpwwn,
 	if (itnim == NULL)
 		return BFA_STATUS_NO_FCPIM_NEXUS;
 
-	attr->state	    = bfa_sm_to_state(itnim_sm_table, itnim->sm);
+	attr->state	    = itnim_sm_to_state(itnim_sm_table, itnim->sm);
 	attr->retry	    = itnim->seq_rec;
 	attr->rec_support   = itnim->rec_support;
 	attr->conf_comp	    = itnim->conf_comp;
diff --git a/drivers/scsi/bfa/bfa_fcs_lport.c b/drivers/scsi/bfa/bfa_fcs_lport.c
index b12afcc4b..c84c526f8 100644
--- a/drivers/scsi/bfa/bfa_fcs_lport.c
+++ b/drivers/scsi/bfa/bfa_fcs_lport.c
@@ -6037,7 +6037,7 @@ static void	bfa_fcs_vport_sm_stopping(struct bfa_fcs_vport_s *vport,
 static void	bfa_fcs_vport_sm_logo_for_stop(struct bfa_fcs_vport_s *vport,
 					enum bfa_fcs_vport_event event);
 
-static struct bfa_sm_table_s  vport_sm_table[] = {
+static struct vport_sm_table_s vport_sm_table[] = {
 	{BFA_SM(bfa_fcs_vport_sm_uninit), BFA_FCS_VPORT_UNINIT},
 	{BFA_SM(bfa_fcs_vport_sm_created), BFA_FCS_VPORT_CREATED},
 	{BFA_SM(bfa_fcs_vport_sm_offline), BFA_FCS_VPORT_OFFLINE},
@@ -6864,7 +6864,7 @@ bfa_fcs_vport_get_attr(struct bfa_fcs_vport_s *vport,
 	memset(attr, 0, sizeof(struct bfa_vport_attr_s));
 
 	bfa_fcs_lport_get_attr(&vport->lport, &attr->port_attr);
-	attr->vport_state = bfa_sm_to_state(vport_sm_table, vport->sm);
+	attr->vport_state = vport_sm_to_state(vport_sm_table, vport->sm);
 }
 
 
diff --git a/drivers/scsi/bfa/bfa_fcs_rport.c b/drivers/scsi/bfa/bfa_fcs_rport.c
index c21aa37b8..6db306c60 100644
--- a/drivers/scsi/bfa/bfa_fcs_rport.c
+++ b/drivers/scsi/bfa/bfa_fcs_rport.c
@@ -136,7 +136,7 @@ static void	bfa_fcs_rport_sm_fc4_off_delete(struct bfa_fcs_rport_s *rport,
 static void	bfa_fcs_rport_sm_delete_pending(struct bfa_fcs_rport_s *rport,
 						enum rport_event event);
 
-static struct bfa_sm_table_s rport_sm_table[] = {
+static struct rport_sm_table_s rport_sm_table[] = {
 	{BFA_SM(bfa_fcs_rport_sm_uninit), BFA_RPORT_UNINIT},
 	{BFA_SM(bfa_fcs_rport_sm_plogi_sending), BFA_RPORT_PLOGI},
 	{BFA_SM(bfa_fcs_rport_sm_plogiacc_sending), BFA_RPORT_ONLINE},
@@ -2964,7 +2964,7 @@ bfa_fcs_rport_send_ls_rjt(struct bfa_fcs_rport_s *rport, struct fchs_s *rx_fchs,
 int
 bfa_fcs_rport_get_state(struct bfa_fcs_rport_s *rport)
 {
-	return bfa_sm_to_state(rport_sm_table, rport->sm);
+	return rport_sm_to_state(rport_sm_table, rport->sm);
 }
 
 
diff --git a/drivers/scsi/bfa/bfa_ioc.c b/drivers/scsi/bfa/bfa_ioc.c
index 5740302d8..9e19e4f5f 100644
--- a/drivers/scsi/bfa/bfa_ioc.c
+++ b/drivers/scsi/bfa/bfa_ioc.c
@@ -140,7 +140,7 @@ bfa_fsm_state_decl(bfa_ioc, disabling, struct bfa_ioc_s, enum ioc_event);
 bfa_fsm_state_decl(bfa_ioc, disabled, struct bfa_ioc_s, enum ioc_event);
 bfa_fsm_state_decl(bfa_ioc, hwfail, struct bfa_ioc_s, enum ioc_event);
 
-static struct bfa_sm_table_s ioc_sm_table[] = {
+static struct ioc_sm_table_s ioc_sm_table[] = {
 	{BFA_SM(bfa_ioc_sm_uninit), BFA_IOC_UNINIT},
 	{BFA_SM(bfa_ioc_sm_reset), BFA_IOC_RESET},
 	{BFA_SM(bfa_ioc_sm_enabling), BFA_IOC_ENABLING},
@@ -228,7 +228,7 @@ bfa_fsm_state_decl(bfa_iocpf, disabling_sync, struct bfa_iocpf_s,
 						enum iocpf_event);
 bfa_fsm_state_decl(bfa_iocpf, disabled, struct bfa_iocpf_s, enum iocpf_event);
 
-static struct bfa_sm_table_s iocpf_sm_table[] = {
+static struct iocpf_sm_table_s iocpf_sm_table[] = {
 	{BFA_SM(bfa_iocpf_sm_reset), BFA_IOCPF_RESET},
 	{BFA_SM(bfa_iocpf_sm_fwcheck), BFA_IOCPF_FWMISMATCH},
 	{BFA_SM(bfa_iocpf_sm_mismatch), BFA_IOCPF_FWMISMATCH},
@@ -2815,12 +2815,12 @@ enum bfa_ioc_state
 bfa_ioc_get_state(struct bfa_ioc_s *ioc)
 {
 	enum bfa_iocpf_state iocpf_st;
-	enum bfa_ioc_state ioc_st = bfa_sm_to_state(ioc_sm_table, ioc->fsm);
+	enum bfa_ioc_state ioc_st = ioc_sm_to_state(ioc_sm_table, ioc->fsm);
 
 	if (ioc_st == BFA_IOC_ENABLING ||
 		ioc_st == BFA_IOC_FAIL || ioc_st == BFA_IOC_INITFAIL) {
 
-		iocpf_st = bfa_sm_to_state(iocpf_sm_table, ioc->iocpf.fsm);
+		iocpf_st = iocpf_sm_to_state(iocpf_sm_table, ioc->iocpf.fsm);
 
 		switch (iocpf_st) {
 		case BFA_IOCPF_SEMWAIT:
diff --git a/drivers/scsi/bfa/bfa_ioc.h b/drivers/scsi/bfa/bfa_ioc.h
index 5e568d6d7..cbf6c3f92 100644
--- a/drivers/scsi/bfa/bfa_ioc.h
+++ b/drivers/scsi/bfa/bfa_ioc.h
@@ -282,16 +282,20 @@ struct bfa_ioc_notify_s {
 	(__notify)->cbarg = (__cbarg);      \
 } while (0)
 
+enum iocpf_event;
+
 struct bfa_iocpf_s {
-	bfa_fsm_t		fsm;
+	void (*fsm)(struct bfa_iocpf_s *, enum iocpf_event);
 	struct bfa_ioc_s	*ioc;
 	bfa_boolean_t		fw_mismatch_notified;
 	bfa_boolean_t		auto_recover;
 	u32			poll_time;
 };
 
+enum ioc_event;
+
 struct bfa_ioc_s {
-	bfa_fsm_t		fsm;
+	void (*fsm)(struct bfa_ioc_s *, enum ioc_event);
 	struct bfa_s		*bfa;
 	struct bfa_pcidev_s	pcidev;
 	struct bfa_timer_mod_s	*timer_mod;
@@ -779,8 +783,10 @@ struct bfa_dconf_s {
 };
 #pragma pack()
 
+enum bfa_dconf_event;
+
 struct bfa_dconf_mod_s {
-	bfa_sm_t		sm;
+	void (*sm)(struct bfa_dconf_mod_s *, enum bfa_dconf_event);
 	u8			instance;
 	bfa_boolean_t		read_data_valid;
 	bfa_boolean_t		min_cfg;
diff --git a/drivers/scsi/bfa/bfa_svc.c b/drivers/scsi/bfa/bfa_svc.c
index 4e3cef02f..6aad7ddcd 100644
--- a/drivers/scsi/bfa/bfa_svc.c
+++ b/drivers/scsi/bfa/bfa_svc.c
@@ -201,7 +201,7 @@ static void     bfa_fcport_ln_sm_up_dn_nf(struct bfa_fcport_ln_s *ln,
 static void     bfa_fcport_ln_sm_up_dn_up_nf(struct bfa_fcport_ln_s *ln,
 					enum bfa_fcport_ln_sm_event event);
 
-static struct bfa_sm_table_s hal_port_sm_table[] = {
+static struct fcport_sm_table_s hal_port_sm_table[] = {
 	{BFA_SM(bfa_fcport_sm_uninit), BFA_PORT_ST_UNINIT},
 	{BFA_SM(bfa_fcport_sm_enabling_qwait), BFA_PORT_ST_ENABLING_QWAIT},
 	{BFA_SM(bfa_fcport_sm_enabling), BFA_PORT_ST_ENABLING},
@@ -3545,7 +3545,7 @@ bfa_fcport_isr(struct bfa_s *bfa, struct bfi_msg_s *msg)
 	fcport->event_arg.i2hmsg = i2hmsg;
 
 	bfa_trc(bfa, msg->mhdr.msg_id);
-	bfa_trc(bfa, bfa_sm_to_state(hal_port_sm_table, fcport->sm));
+	bfa_trc(bfa, fcport_sm_to_state(hal_port_sm_table, fcport->sm));
 
 	switch (msg->mhdr.msg_id) {
 	case BFI_FCPORT_I2H_ENABLE_RSP:
@@ -3980,7 +3980,7 @@ bfa_fcport_get_attr(struct bfa_s *bfa, struct bfa_port_attr_s *attr)
 
 	attr->pport_cfg.path_tov  = bfa_fcpim_path_tov_get(bfa);
 	attr->pport_cfg.q_depth  = bfa_fcpim_qdepth_get(bfa);
-	attr->port_state = bfa_sm_to_state(hal_port_sm_table, fcport->sm);
+	attr->port_state = fcport_sm_to_state(hal_port_sm_table, fcport->sm);
 
 	attr->fec_state = fcport->fec_state;
 
@@ -4062,7 +4062,7 @@ bfa_fcport_is_disabled(struct bfa_s *bfa)
 {
 	struct bfa_fcport_s *fcport = BFA_FCPORT_MOD(bfa);
 
-	return bfa_sm_to_state(hal_port_sm_table, fcport->sm) ==
+	return fcport_sm_to_state(hal_port_sm_table, fcport->sm) ==
 		BFA_PORT_ST_DISABLED;
 
 }
@@ -4072,7 +4072,7 @@ bfa_fcport_is_dport(struct bfa_s *bfa)
 {
 	struct bfa_fcport_s *fcport = BFA_FCPORT_MOD(bfa);
 
-	return (bfa_sm_to_state(hal_port_sm_table, fcport->sm) ==
+	return (fcport_sm_to_state(hal_port_sm_table, fcport->sm) ==
 		BFA_PORT_ST_DPORT);
 }
 
@@ -4081,7 +4081,7 @@ bfa_fcport_is_ddport(struct bfa_s *bfa)
 {
 	struct bfa_fcport_s *fcport = BFA_FCPORT_MOD(bfa);
 
-	return (bfa_sm_to_state(hal_port_sm_table, fcport->sm) ==
+	return (fcport_sm_to_state(hal_port_sm_table, fcport->sm) ==
 		BFA_PORT_ST_DDPORT);
 }
 
diff --git a/drivers/scsi/bfa/bfa_svc.h b/drivers/scsi/bfa/bfa_svc.h
index 9c8310957..5a4ad66bc 100644
--- a/drivers/scsi/bfa/bfa_svc.h
+++ b/drivers/scsi/bfa/bfa_svc.h
@@ -152,6 +152,8 @@ struct bfa_fcxp_rsp_info_s {
 	u32	rsp_maxlen;	/*  max response length expected */
 };
 
+typedef void (*bfa_sm_t)(void *sm, int event);
+
 struct bfa_fcxp_s {
 	struct list_head	qe;		/*  fcxp queue element */
 	bfa_sm_t	sm;		/*  state machine */
@@ -287,9 +289,11 @@ struct bfa_rport_info_s {
 /*
  * BFA rport data structure
  */
+enum bfa_rport_event;
+
 struct bfa_rport_s {
 	struct list_head	qe;	/*  queue element		    */
-	bfa_sm_t	sm;		/*  state machine		    */
+	void (*sm)(struct bfa_rport_s *, enum bfa_rport_event);/*  state machine		    */
 	struct bfa_s	*bfa;		/*  backpointer to BFA		    */
 	void		*rport_drv;	/*  fcs/driver rport object	    */
 	u16	fw_handle;	/*  firmware rport handle	    */
@@ -380,10 +384,12 @@ void	bfa_uf_res_recfg(struct bfa_s *bfa, u16 num_uf_fw);
 /*
  * LPS - bfa lport login/logout service interface
  */
+enum bfa_lps_event;
+
 struct bfa_lps_s {
 	struct list_head	qe;	/*  queue element		*/
 	struct bfa_s	*bfa;		/*  parent bfa instance	*/
-	bfa_sm_t	sm;		/*  finite state machine	*/
+	void (*sm)(struct bfa_lps_s *, enum bfa_lps_event);/*  finite state machine	*/
 	u8		bfa_tag;	/*  lport tag		*/
 	u8		fw_tag;		/*  lport fw tag                */
 	u8		reqq;		/*  lport request queue	*/
@@ -442,9 +448,11 @@ void	bfa_lps_isr(struct bfa_s *bfa, struct bfi_msg_s *msg);
 /*
  * Link notification data structure
  */
+enum bfa_fcport_ln_sm_event;
+
 struct bfa_fcport_ln_s {
 	struct bfa_fcport_s	*fcport;
-	bfa_sm_t		sm;
+	void (*sm)(struct bfa_fcport_ln_s *, enum bfa_fcport_ln_sm_event);
 	struct bfa_cb_qe_s	ln_qe;	/*  BFA callback queue elem for ln */
 	enum bfa_port_linkstate ln_event; /*  ln event for callback */
 };
@@ -458,7 +466,7 @@ struct bfa_fcport_trunk_s {
  */
 struct bfa_fcport_s {
 	struct bfa_s		*bfa;	/*  parent BFA instance */
-	bfa_sm_t		sm;	/*  port state machine */
+	void (*sm)(struct bfa_fcport_s *, enum bfa_fcport_sm_event);	/*  port state machine */
 	wwn_t			nwwn;	/*  node wwn of physical port */
 	wwn_t			pwwn;	/*  port wwn of physical oprt */
 	enum bfa_port_speed speed_sup;
@@ -706,9 +714,11 @@ struct bfa_fcdiag_lb_s {
 	u32        status;
 };
 
+enum bfa_dport_sm_event;
+
 struct bfa_dport_s {
 	struct bfa_s	*bfa;		/* Back pointer to BFA	*/
-	bfa_sm_t	sm;		/* finite state machine */
+	void (*sm)(struct bfa_dport_s *, enum bfa_dport_sm_event);/* finite state machine */
 	struct bfa_reqq_wait_s reqq_wait;
 	bfa_cb_diag_t	cbfn;
 	void		*cbarg;
diff --git a/drivers/scsi/bfa/bfad.c b/drivers/scsi/bfa/bfad.c
index e5aa982ff..4f9dd0b8a 100644
--- a/drivers/scsi/bfa/bfad.c
+++ b/drivers/scsi/bfa/bfad.c
@@ -400,6 +400,16 @@ bfad_hcb_comp(void *arg, bfa_status_t status)
 	complete(&fcomp->comp);
 }
 
+void
+bfad_stats_comp(void *arg, bfa_boolean_t _status)
+{
+	struct bfad_hal_comp *fcomp = (struct bfad_hal_comp *)arg;
+	bfa_status_t status = (bfa_status_t)_status;
+
+	fcomp->status = status;
+	complete(&fcomp->comp);
+}
+
 /*
  * bfa_init callback
  */
@@ -1429,7 +1439,7 @@ bfad_pci_remove(struct pci_dev *pdev)
  * PCI Error Recovery entry, error detected.
  */
 static pci_ers_result_t
-bfad_pci_error_detected(struct pci_dev *pdev, pci_channel_state_t state)
+bfad_pci_error_detected(struct pci_dev *pdev, enum pci_channel_state state)
 {
 	struct bfad_s *bfad = pci_get_drvdata(pdev);
 	unsigned long	flags;
diff --git a/drivers/scsi/bfa/bfad_drv.h b/drivers/scsi/bfa/bfad_drv.h
index eaee7c8bc..1c0368fbe 100644
--- a/drivers/scsi/bfa/bfad_drv.h
+++ b/drivers/scsi/bfa/bfad_drv.h
@@ -179,8 +179,10 @@ union bfad_tmp_buf {
 /*
  * BFAD (PCI function) data structure
  */
+enum bfad_sm_event;
+
 struct bfad_s {
-	bfa_sm_t	sm;	/* state machine */
+	void (*sm)(struct bfad_s *, enum bfad_sm_event); /* state machine */
 	struct list_head list_entry;
 	struct bfa_s	bfa;
 	struct bfa_fcs_s bfa_fcs;
@@ -301,6 +303,7 @@ void		bfad_fcs_stop(struct bfad_s *bfad);
 void		bfad_remove_intr(struct bfad_s *bfad);
 void		bfad_hal_mem_release(struct bfad_s *bfad);
 void		bfad_hcb_comp(void *arg, bfa_status_t status);
+void		bfad_stats_comp(void *arg, bfa_boolean_t _status);
 
 int		bfad_setup_intr(struct bfad_s *bfad);
 void		bfad_remove_intr(struct bfad_s *bfad);
diff --git a/drivers/scsi/csiostor/csio_defs.h b/drivers/scsi/csiostor/csio_defs.h
index e50e93e7f..71327b224 100644
--- a/drivers/scsi/csiostor/csio_defs.h
+++ b/drivers/scsi/csiostor/csio_defs.h
@@ -87,7 +87,8 @@ enum csio_ln_ev {
 	CSIO_LNE_MAX_EVENT,
 };
 
-typedef void (*csio_sm_state_t)(struct csio_lnode *ln, enum csio_ln_ev evt);
+struct csio_sm;
+typedef void (*csio_sm_state_t)(struct csio_sm *, uint32_t);
 
 struct csio_sm {
 	struct list_head	sm_list;
@@ -95,9 +96,9 @@ struct csio_sm {
 };
 
 static inline void
-csio_set_state(void *smp, void *state)
+csio_set_state(struct csio_sm *smp, csio_sm_state_t state)
 {
-	((struct csio_sm *)smp)->sm_state = state;
+	smp->sm_state = state;
 }
 
 static inline void
@@ -107,21 +108,21 @@ csio_init_state(struct csio_sm *smp, void *state)
 }
 
 static inline void
-csio_post_event(void *smp, uint32_t evt)
+csio_post_event(struct csio_sm *smp, uint32_t evt)
 {
-	((struct csio_sm *)smp)->sm_state(smp, evt);
+	smp->sm_state(smp, evt);
 }
 
 static inline csio_sm_state_t
-csio_get_state(void *smp)
+csio_get_state(struct csio_sm *smp)
 {
-	return ((struct csio_sm *)smp)->sm_state;
+	return smp->sm_state;
 }
 
 static inline bool
-csio_match_state(void *smp, void *state)
+csio_match_state(struct csio_sm *smp, csio_sm_state_t state)
 {
-	return (csio_get_state(smp) == (csio_sm_state_t)state);
+	return (csio_get_state(smp) == state);
 }
 
 #define	CSIO_ASSERT(cond)		BUG_ON(!(cond))
diff --git a/drivers/scsi/csiostor/csio_hw.c b/drivers/scsi/csiostor/csio_hw.c
index e43c5413c..3ee049d50 100644
--- a/drivers/scsi/csiostor/csio_hw.c
+++ b/drivers/scsi/csiostor/csio_hw.c
@@ -89,15 +89,15 @@ static void csio_mgmtm_cleanup(struct csio_mgmtm *);
 static void csio_hw_mbm_cleanup(struct csio_hw *);
 
 /* State machine forward declarations */
-static void csio_hws_uninit(struct csio_hw *, enum csio_hw_ev);
-static void csio_hws_configuring(struct csio_hw *, enum csio_hw_ev);
-static void csio_hws_initializing(struct csio_hw *, enum csio_hw_ev);
-static void csio_hws_ready(struct csio_hw *, enum csio_hw_ev);
-static void csio_hws_quiescing(struct csio_hw *, enum csio_hw_ev);
-static void csio_hws_quiesced(struct csio_hw *, enum csio_hw_ev);
-static void csio_hws_resetting(struct csio_hw *, enum csio_hw_ev);
-static void csio_hws_removing(struct csio_hw *, enum csio_hw_ev);
-static void csio_hws_pcierr(struct csio_hw *, enum csio_hw_ev);
+static void csio_hws_uninit(struct csio_sm *, uint32_t);
+static void csio_hws_configuring(struct csio_sm *, uint32_t);
+static void csio_hws_initializing(struct csio_sm *, uint32_t);
+static void csio_hws_ready(struct csio_sm *, uint32_t);
+static void csio_hws_quiescing(struct csio_sm *, uint32_t);
+static void csio_hws_quiesced(struct csio_sm *, uint32_t);
+static void csio_hws_resetting(struct csio_sm *, uint32_t);
+static void csio_hws_removing(struct csio_sm *, uint32_t);
+static void csio_hws_pcierr(struct csio_sm *, uint32_t);
 
 static void csio_hw_initialize(struct csio_hw *hw);
 static void csio_evtq_stop(struct csio_hw *hw);
@@ -105,12 +105,12 @@ static void csio_evtq_start(struct csio_hw *hw);
 
 int csio_is_hw_ready(struct csio_hw *hw)
 {
-	return csio_match_state(hw, csio_hws_ready);
+	return csio_match_state(&hw->sm, csio_hws_ready);
 }
 
 int csio_is_hw_removing(struct csio_hw *hw)
 {
-	return csio_match_state(hw, csio_hws_removing);
+	return csio_match_state(&hw->sm, csio_hws_removing);
 }
 
 
@@ -2777,8 +2777,11 @@ csio_hw_fatal_err(struct csio_hw *hw)
  *
  */
 static void
-csio_hws_uninit(struct csio_hw *hw, enum csio_hw_ev evt)
+csio_hws_uninit(struct csio_sm *_hw, uint32_t _evt)
 {
+	struct csio_hw *hw = container_of(_hw, struct csio_hw, sm);
+	enum csio_hw_ev evt = _evt;
+
 	hw->prev_evt = hw->cur_evt;
 	hw->cur_evt = evt;
 	CSIO_INC_STATS(hw, n_evt_sm[evt]);
@@ -2802,8 +2805,11 @@ csio_hws_uninit(struct csio_hw *hw, enum csio_hw_ev evt)
  *
  */
 static void
-csio_hws_configuring(struct csio_hw *hw, enum csio_hw_ev evt)
+csio_hws_configuring(struct csio_sm *_hw, uint32_t _evt)
 {
+	struct csio_hw *hw = container_of(_hw, struct csio_hw, sm);
+	enum csio_hw_ev evt = _evt;
+
 	hw->prev_evt = hw->cur_evt;
 	hw->cur_evt = evt;
 	CSIO_INC_STATS(hw, n_evt_sm[evt]);
@@ -2840,8 +2846,11 @@ csio_hws_configuring(struct csio_hw *hw, enum csio_hw_ev evt)
  *
  */
 static void
-csio_hws_initializing(struct csio_hw *hw, enum csio_hw_ev evt)
+csio_hws_initializing(struct csio_sm *_hw, uint32_t _evt)
 {
+	struct csio_hw *hw = container_of(_hw, struct csio_hw, sm);
+	enum csio_hw_ev evt = _evt;
+
 	hw->prev_evt = hw->cur_evt;
 	hw->cur_evt = evt;
 	CSIO_INC_STATS(hw, n_evt_sm[evt]);
@@ -2878,8 +2887,11 @@ csio_hws_initializing(struct csio_hw *hw, enum csio_hw_ev evt)
  *
  */
 static void
-csio_hws_ready(struct csio_hw *hw, enum csio_hw_ev evt)
+csio_hws_ready(struct csio_sm *_hw, uint32_t _evt)
 {
+	struct csio_hw *hw = container_of(_hw, struct csio_hw, sm);
+	enum csio_hw_ev evt = _evt;
+
 	/* Remember the event */
 	hw->evtflag = evt;
 
@@ -2927,8 +2939,11 @@ csio_hws_ready(struct csio_hw *hw, enum csio_hw_ev evt)
  *
  */
 static void
-csio_hws_quiescing(struct csio_hw *hw, enum csio_hw_ev evt)
+csio_hws_quiescing(struct csio_sm *_hw, uint32_t _evt)
 {
+	struct csio_hw *hw = container_of(_hw, struct csio_hw, sm);
+	enum csio_hw_ev evt = _evt;
+
 	hw->prev_evt = hw->cur_evt;
 	hw->cur_evt = evt;
 	CSIO_INC_STATS(hw, n_evt_sm[evt]);
@@ -2987,8 +3002,11 @@ csio_hws_quiescing(struct csio_hw *hw, enum csio_hw_ev evt)
  *
  */
 static void
-csio_hws_quiesced(struct csio_hw *hw, enum csio_hw_ev evt)
+csio_hws_quiesced(struct csio_sm *_hw, uint32_t _evt)
 {
+	struct csio_hw *hw = container_of(_hw, struct csio_hw, sm);
+	enum csio_hw_ev evt = _evt;
+
 	hw->prev_evt = hw->cur_evt;
 	hw->cur_evt = evt;
 	CSIO_INC_STATS(hw, n_evt_sm[evt]);
@@ -3012,8 +3030,11 @@ csio_hws_quiesced(struct csio_hw *hw, enum csio_hw_ev evt)
  *
  */
 static void
-csio_hws_resetting(struct csio_hw *hw, enum csio_hw_ev evt)
+csio_hws_resetting(struct csio_sm *_hw, uint32_t _evt)
 {
+	struct csio_hw *hw = container_of(_hw, struct csio_hw, sm);
+	enum csio_hw_ev evt = _evt;
+
 	hw->prev_evt = hw->cur_evt;
 	hw->cur_evt = evt;
 	CSIO_INC_STATS(hw, n_evt_sm[evt]);
@@ -3038,8 +3059,11 @@ csio_hws_resetting(struct csio_hw *hw, enum csio_hw_ev evt)
  *
  */
 static void
-csio_hws_removing(struct csio_hw *hw, enum csio_hw_ev evt)
+csio_hws_removing(struct csio_sm *_hw, uint32_t _evt)
 {
+	struct csio_hw *hw = container_of(_hw, struct csio_hw, sm);
+	enum csio_hw_ev evt = _evt;
+
 	hw->prev_evt = hw->cur_evt;
 	hw->cur_evt = evt;
 	CSIO_INC_STATS(hw, n_evt_sm[evt]);
@@ -3073,8 +3097,11 @@ csio_hws_removing(struct csio_hw *hw, enum csio_hw_ev evt)
  *
  */
 static void
-csio_hws_pcierr(struct csio_hw *hw, enum csio_hw_ev evt)
+csio_hws_pcierr(struct csio_sm *_hw, uint32_t _evt)
 {
+	struct csio_hw *hw = container_of(_hw, struct csio_hw, sm);
+	enum csio_hw_ev evt = _evt;
+
 	hw->prev_evt = hw->cur_evt;
 	hw->cur_evt = evt;
 	CSIO_INC_STATS(hw, n_evt_sm[evt]);
@@ -4231,7 +4258,7 @@ csio_hw_start(struct csio_hw *hw)
 
 	if (csio_is_hw_ready(hw))
 		return 0;
-	else if (csio_match_state(hw, csio_hws_uninit))
+	else if (csio_match_state(&hw->sm, csio_hws_uninit))
 		return -EINVAL;
 	else
 		return -ENODEV;
diff --git a/drivers/scsi/csiostor/csio_init.c b/drivers/scsi/csiostor/csio_init.c
index ccbded335..59de675c4 100644
--- a/drivers/scsi/csiostor/csio_init.c
+++ b/drivers/scsi/csiostor/csio_init.c
@@ -1054,7 +1054,7 @@ static void csio_remove_one(struct pci_dev *pdev)
  *
  */
 static pci_ers_result_t
-csio_pci_error_detected(struct pci_dev *pdev, pci_channel_state_t state)
+csio_pci_error_detected(struct pci_dev *pdev, enum pci_channel_state state)
 {
 	struct csio_hw *hw = pci_get_drvdata(pdev);
 
diff --git a/drivers/scsi/csiostor/csio_lnode.c b/drivers/scsi/csiostor/csio_lnode.c
index 5b3ffefae..f8db0065d 100644
--- a/drivers/scsi/csiostor/csio_lnode.c
+++ b/drivers/scsi/csiostor/csio_lnode.c
@@ -55,10 +55,10 @@ int csio_fdmi_enable = 1;
 #define PORT_ID_PTR(_x)         ((uint8_t *)(&_x) + 1)
 
 /* Lnode SM declarations */
-static void csio_lns_uninit(struct csio_lnode *, enum csio_ln_ev);
-static void csio_lns_online(struct csio_lnode *, enum csio_ln_ev);
-static void csio_lns_ready(struct csio_lnode *, enum csio_ln_ev);
-static void csio_lns_offline(struct csio_lnode *, enum csio_ln_ev);
+static void csio_lns_uninit(struct csio_sm *, uint32_t);
+static void csio_lns_online(struct csio_sm *, uint32_t);
+static void csio_lns_ready(struct csio_sm *, uint32_t);
+static void csio_lns_offline(struct csio_sm *, uint32_t);
 
 static int csio_ln_mgmt_submit_req(struct csio_ioreq *,
 		void (*io_cbfn) (struct csio_hw *, struct csio_ioreq *),
@@ -1095,7 +1095,7 @@ csio_handle_link_down(struct csio_hw *hw, uint8_t portid, uint32_t fcfi,
 int
 csio_is_lnode_ready(struct csio_lnode *ln)
 {
-	return (csio_get_state(ln) == csio_lns_ready);
+	return (csio_get_state(&ln->sm) == csio_lns_ready);
 }
 
 /*****************************************************************************/
@@ -1111,8 +1111,10 @@ csio_is_lnode_ready(struct csio_lnode *ln)
  * Return - none.
  */
 static void
-csio_lns_uninit(struct csio_lnode *ln, enum csio_ln_ev evt)
+csio_lns_uninit(struct csio_sm *_ln, uint32_t _evt)
 {
+	struct csio_lnode *ln = container_of(_ln, struct csio_lnode, sm);
+	enum csio_ln_ev evt = _evt;
 	struct csio_hw *hw = csio_lnode_to_hw(ln);
 	struct csio_lnode *rln = hw->rln;
 	int rv;
@@ -1164,8 +1166,10 @@ csio_lns_uninit(struct csio_lnode *ln, enum csio_ln_ev evt)
  * Return - none.
  */
 static void
-csio_lns_online(struct csio_lnode *ln, enum csio_ln_ev evt)
+csio_lns_online(struct csio_sm *_ln, uint32_t _evt)
 {
+	struct csio_lnode *ln = container_of(_ln, struct csio_lnode, sm);
+	enum csio_ln_ev evt = _evt;
 	struct csio_hw *hw = csio_lnode_to_hw(ln);
 
 	CSIO_INC_STATS(ln, n_evt_sm[evt]);
@@ -1215,8 +1219,10 @@ csio_lns_online(struct csio_lnode *ln, enum csio_ln_ev evt)
  * Return - none.
  */
 static void
-csio_lns_ready(struct csio_lnode *ln, enum csio_ln_ev evt)
+csio_lns_ready(struct csio_sm *_ln, uint32_t _evt)
 {
+	struct csio_lnode *ln = container_of(_ln, struct csio_lnode, sm);
+	enum csio_ln_ev evt = _evt;
 	struct csio_hw *hw = csio_lnode_to_hw(ln);
 
 	CSIO_INC_STATS(ln, n_evt_sm[evt]);
@@ -1289,8 +1295,10 @@ csio_lns_ready(struct csio_lnode *ln, enum csio_ln_ev evt)
  * Return - none.
  */
 static void
-csio_lns_offline(struct csio_lnode *ln, enum csio_ln_ev evt)
+csio_lns_offline(struct csio_sm *_ln, uint32_t _evt)
 {
+	struct csio_lnode *ln = container_of(_ln, struct csio_lnode, sm);
+	enum csio_ln_ev evt = _evt;
 	struct csio_hw *hw = csio_lnode_to_hw(ln);
 	struct csio_lnode *rln = hw->rln;
 	int rv;
@@ -1366,15 +1374,15 @@ csio_free_fcfinfo(struct kref *kref)
 void
 csio_lnode_state_to_str(struct csio_lnode *ln, int8_t *str)
 {
-	if (csio_get_state(ln) == csio_lns_uninit) {
+	if (csio_get_state(&ln->sm) == csio_lns_uninit) {
 		strcpy(str, "UNINIT");
 		return;
 	}
-	if (csio_get_state(ln) == csio_lns_ready) {
+	if (csio_get_state(&ln->sm) == csio_lns_ready) {
 		strcpy(str, "READY");
 		return;
 	}
-	if (csio_get_state(ln) == csio_lns_offline) {
+	if (csio_get_state(&ln->sm) == csio_lns_offline) {
 		strcpy(str, "OFFLINE");
 		return;
 	}
diff --git a/drivers/scsi/csiostor/csio_rnode.c b/drivers/scsi/csiostor/csio_rnode.c
index 713e13adf..dcbdf1125 100644
--- a/drivers/scsi/csiostor/csio_rnode.c
+++ b/drivers/scsi/csiostor/csio_rnode.c
@@ -46,10 +46,10 @@ static int csio_rnode_init(struct csio_rnode *, struct csio_lnode *);
 static void csio_rnode_exit(struct csio_rnode *);
 
 /* Static machine forward declarations */
-static void csio_rns_uninit(struct csio_rnode *, enum csio_rn_ev);
-static void csio_rns_ready(struct csio_rnode *, enum csio_rn_ev);
-static void csio_rns_offline(struct csio_rnode *, enum csio_rn_ev);
-static void csio_rns_disappeared(struct csio_rnode *, enum csio_rn_ev);
+static void csio_rns_uninit(struct csio_sm *, uint32_t);
+static void csio_rns_ready(struct csio_sm *, uint32_t);
+static void csio_rns_offline(struct csio_sm *, uint32_t);
+static void csio_rns_disappeared(struct csio_sm *, uint32_t);
 
 /* RNF event mapping */
 static enum csio_rn_ev fwevt_to_rnevt[] = {
@@ -88,13 +88,13 @@ static enum csio_rn_ev fwevt_to_rnevt[] = {
 int
 csio_is_rnode_ready(struct csio_rnode *rn)
 {
-	return csio_match_state(rn, csio_rns_ready);
+	return csio_match_state(&rn->sm, csio_rns_ready);
 }
 
 static int
 csio_is_rnode_uninit(struct csio_rnode *rn)
 {
-	return csio_match_state(rn, csio_rns_uninit);
+	return csio_match_state(&rn->sm, csio_rns_uninit);
 }
 
 static int
@@ -601,8 +601,10 @@ __csio_unreg_rnode(struct csio_rnode *rn)
  *
  */
 static void
-csio_rns_uninit(struct csio_rnode *rn, enum csio_rn_ev evt)
+csio_rns_uninit(struct csio_sm *_rn, uint32_t _evt)
 {
+	struct csio_rnode *rn = container_of(_rn, struct csio_rnode, sm);
+	enum csio_rn_ev evt = _evt;
 	struct csio_lnode *ln = csio_rnode_to_lnode(rn);
 	int ret = 0;
 
@@ -641,8 +643,10 @@ csio_rns_uninit(struct csio_rnode *rn, enum csio_rn_ev evt)
  *
  */
 static void
-csio_rns_ready(struct csio_rnode *rn, enum csio_rn_ev evt)
+csio_rns_ready(struct csio_sm *_rn, uint32_t _evt)
 {
+	struct csio_rnode *rn = container_of(_rn, struct csio_rnode, sm);
+	enum csio_rn_ev evt = _evt;
 	struct csio_lnode *ln = csio_rnode_to_lnode(rn);
 	int ret = 0;
 
@@ -726,8 +730,10 @@ csio_rns_ready(struct csio_rnode *rn, enum csio_rn_ev evt)
  *
  */
 static void
-csio_rns_offline(struct csio_rnode *rn, enum csio_rn_ev evt)
+csio_rns_offline(struct csio_sm *_rn, uint32_t _evt)
 {
+	struct csio_rnode *rn = container_of(_rn, struct csio_rnode, sm);
+	enum csio_rn_ev evt = _evt;
 	struct csio_lnode *ln = csio_rnode_to_lnode(rn);
 	int ret = 0;
 
@@ -785,8 +791,10 @@ csio_rns_offline(struct csio_rnode *rn, enum csio_rn_ev evt)
  *
  */
 static void
-csio_rns_disappeared(struct csio_rnode *rn, enum csio_rn_ev evt)
+csio_rns_disappeared(struct csio_sm *_rn, uint32_t _evt)
 {
+	struct csio_rnode *rn = container_of(_rn, struct csio_rnode, sm);
+	enum csio_rn_ev evt = _evt;
 	struct csio_lnode *ln = csio_rnode_to_lnode(rn);
 	int ret = 0;
 
diff --git a/drivers/scsi/csiostor/csio_scsi.c b/drivers/scsi/csiostor/csio_scsi.c
index 05e1a63e0..3b5dff3b6 100644
--- a/drivers/scsi/csiostor/csio_scsi.c
+++ b/drivers/scsi/csiostor/csio_scsi.c
@@ -65,12 +65,12 @@ static int csio_ddp_descs = 128;
 static int csio_do_abrt_cls(struct csio_hw *,
 				      struct csio_ioreq *, bool);
 
-static void csio_scsis_uninit(struct csio_ioreq *, enum csio_scsi_ev);
-static void csio_scsis_io_active(struct csio_ioreq *, enum csio_scsi_ev);
-static void csio_scsis_tm_active(struct csio_ioreq *, enum csio_scsi_ev);
-static void csio_scsis_aborting(struct csio_ioreq *, enum csio_scsi_ev);
-static void csio_scsis_closing(struct csio_ioreq *, enum csio_scsi_ev);
-static void csio_scsis_shost_cmpl_await(struct csio_ioreq *, enum csio_scsi_ev);
+static void csio_scsis_uninit(struct csio_sm *, uint32_t);
+static void csio_scsis_io_active(struct csio_sm *, uint32_t);
+static void csio_scsis_tm_active(struct csio_sm *, uint32_t);
+static void csio_scsis_aborting(struct csio_sm *, uint32_t);
+static void csio_scsis_closing(struct csio_sm *, uint32_t);
+static void csio_scsis_shost_cmpl_await(struct csio_sm *, uint32_t);
 
 /*
  * csio_scsi_match_io - Match an ioreq with the given SCSI level data.
@@ -700,8 +700,10 @@ csio_scsi_abrt_cls(struct csio_ioreq *req, bool abort)
 /* START: SCSI SM                                                            */
 /*****************************************************************************/
 static void
-csio_scsis_uninit(struct csio_ioreq *req, enum csio_scsi_ev evt)
+csio_scsis_uninit(struct csio_sm *_req, uint32_t _evt)
 {
+	struct csio_ioreq *req = container_of(_req, struct csio_ioreq, sm);
+	enum csio_scsi_ev evt = _evt;
 	struct csio_hw *hw = req->lnode->hwp;
 	struct csio_scsim *scsim = csio_hw_to_scsim(hw);
 
@@ -770,8 +772,10 @@ csio_scsis_uninit(struct csio_ioreq *req, enum csio_scsi_ev evt)
 }
 
 static void
-csio_scsis_io_active(struct csio_ioreq *req, enum csio_scsi_ev evt)
+csio_scsis_io_active(struct csio_sm *_req, uint32_t _evt)
 {
+	struct csio_ioreq *req = container_of(_req, struct csio_ioreq, sm);
+	enum csio_scsi_ev evt = _evt;
 	struct csio_hw *hw = req->lnode->hwp;
 	struct csio_scsim *scm = csio_hw_to_scsim(hw);
 	struct csio_rnode *rn;
@@ -842,8 +846,10 @@ csio_scsis_io_active(struct csio_ioreq *req, enum csio_scsi_ev evt)
 }
 
 static void
-csio_scsis_tm_active(struct csio_ioreq *req, enum csio_scsi_ev evt)
+csio_scsis_tm_active(struct csio_sm *_req, uint32_t _evt)
 {
+	struct csio_ioreq *req = container_of(_req, struct csio_ioreq, sm);
+	enum csio_scsi_ev evt = _evt;
 	struct csio_hw *hw = req->lnode->hwp;
 	struct csio_scsim *scm = csio_hw_to_scsim(hw);
 
@@ -885,8 +891,10 @@ csio_scsis_tm_active(struct csio_ioreq *req, enum csio_scsi_ev evt)
 }
 
 static void
-csio_scsis_aborting(struct csio_ioreq *req, enum csio_scsi_ev evt)
+csio_scsis_aborting(struct csio_sm *_req, uint32_t _evt)
 {
+	struct csio_ioreq *req = container_of(_req, struct csio_ioreq, sm);
+	enum csio_scsi_ev evt = _evt;
 	struct csio_hw *hw = req->lnode->hwp;
 	struct csio_scsim *scm = csio_hw_to_scsim(hw);
 
@@ -982,8 +990,10 @@ csio_scsis_aborting(struct csio_ioreq *req, enum csio_scsi_ev evt)
 }
 
 static void
-csio_scsis_closing(struct csio_ioreq *req, enum csio_scsi_ev evt)
+csio_scsis_closing(struct csio_sm *_req, uint32_t _evt)
 {
+	struct csio_ioreq *req = container_of(_req, struct csio_ioreq, sm);
+	enum csio_scsi_ev evt = _evt;
 	struct csio_hw *hw = req->lnode->hwp;
 	struct csio_scsim *scm = csio_hw_to_scsim(hw);
 
@@ -1046,8 +1056,11 @@ csio_scsis_closing(struct csio_ioreq *req, enum csio_scsi_ev evt)
 }
 
 static void
-csio_scsis_shost_cmpl_await(struct csio_ioreq *req, enum csio_scsi_ev evt)
+csio_scsis_shost_cmpl_await(struct csio_sm *_req, uint32_t _evt)
 {
+	struct csio_ioreq *req = container_of(_req, struct csio_ioreq, sm);
+	enum csio_scsi_ev evt = _evt;
+
 	switch (evt) {
 	case CSIO_SCSIE_ABORT:
 	case CSIO_SCSIE_CLOSE:
diff --git a/include/linux/cfi_types.h b/include/linux/cfi_types.h
index 6b8713675..6f3fe6a60 100644
--- a/include/linux/cfi_types.h
+++ b/include/linux/cfi_types.h
@@ -20,11 +20,19 @@
 	.4byte __kcfi_typeid_##name
 #endif
 
+#ifdef CONFIG_PAX_RAP
+#define SYM_TYPED_ENTRY(name, linkage, align...)	\
+	linkage(name) ASM_NL				\
+	align ASM_NL					\
+	__RAP_TYPE(name) ASM_NL				\
+	name:
+#else
 #define SYM_TYPED_ENTRY(name, linkage, align...)	\
 	linkage(name) ASM_NL				\
 	align ASM_NL					\
 	__CFI_TYPE(name) ASM_NL				\
 	name:
+#endif
 
 #define SYM_TYPED_START(name, linkage, align...)	\
 	SYM_TYPED_ENTRY(name, linkage, align)
diff --git a/include/linux/compiler_types.h b/include/linux/compiler_types.h
index 574b4121e..5d9f44ea9 100644
--- a/include/linux/compiler_types.h
+++ b/include/linux/compiler_types.h
@@ -326,6 +326,10 @@ struct ftrace_likely_data {
 			 __scalar_type_to_expr_cases(long long),	\
 			 default: (x)))
 
+#define __type_is_unsigned(t) \
+	(__same_type((t)0, 0UL) || __same_type((t)0, 0U) || \
+	__same_type((t)0, (unsigned short)0) || __same_type((t)0, (unsigned char)0))
+
 /* Is this type a native word size -- useful for atomic operations */
 #define __native_word(t) \
 	(sizeof(t) == sizeof(char) || sizeof(t) == sizeof(short) || \
diff --git a/include/linux/moduleparam.h b/include/linux/moduleparam.h
index 962cd41a2..b50341126 100644
--- a/include/linux/moduleparam.h
+++ b/include/linux/moduleparam.h
@@ -354,7 +354,7 @@ static inline void kernel_param_unlock(struct module *mod)
  * @len is usually just sizeof(string).
  */
 #define module_param_string(name, string, len, perm)			\
-	static const struct kparam_string __param_string_##name		\
+	static const struct kparam_string __param_string_##name __used	\
 		= { len, string };					\
 	__module_param_call(MODULE_PARAM_PREFIX, name,			\
 			    &param_ops_string,				\
@@ -513,7 +513,7 @@ extern int param_set_bint(const char *val, const struct kernel_param *kp);
  */
 #define module_param_array_named(name, array, type, nump, perm)		\
 	param_check_##type(name, &(array)[0]);				\
-	static const struct kparam_array __param_arr_##name		\
+	static const struct kparam_array __param_arr_##name __used	\
 	= { .max = ARRAY_SIZE(array), .num = nump,                      \
 	    .ops = &param_ops_##type,					\
 	    .elemsize = sizeof(array[0]), .elem = array };		\
diff --git a/include/linux/pci.h b/include/linux/pci.h
index 4da7411da..9506a4f38 100644
--- a/include/linux/pci.h
+++ b/include/linux/pci.h
@@ -194,7 +194,7 @@ static inline const char *pci_power_name(pci_power_t state)
  */
 typedef unsigned int __bitwise pci_channel_state_t;
 
-enum {
+enum pci_channel_state {
 	/* I/O channel is in normal state */
 	pci_channel_io_normal = (__force pci_channel_state_t) 1,
 
diff --git a/include/linux/syscalls.h b/include/linux/syscalls.h
index 27a6ba1c0..617be02cf 100644
--- a/include/linux/syscalls.h
+++ b/include/linux/syscalls.h
@@ -122,8 +122,14 @@ enum landlock_rule_type;
 #define __TYPE_IS_UL(t)	(__TYPE_AS(t, 0UL))
 #define __TYPE_IS_LL(t) (__TYPE_AS(t, 0LL) || __TYPE_AS(t, 0ULL))
 #define __SC_LONG(t, a) __typeof(__builtin_choose_expr(__TYPE_IS_LL(t), 0LL, 0L)) a
+#define __SC_TYPE(t, a) __typeof__(                               \
+       __builtin_choose_expr(                                  \
+               sizeof(t) > sizeof(int),                        \
+               (t) 0,                                          \
+               __builtin_choose_expr(__type_is_unsigned(t), 0UL, 0L)   \
+       ))
+#define __SC_WRAP(t, a)        (__SC_TYPE(t, a)) a
 #define __SC_CAST(t, a)	(__force t) a
-#define __SC_TYPE(t, a)	t
 #define __SC_ARGS(t, a)	a
 #define __SC_TEST(t, a) (void)BUILD_BUG_ON_ZERO(!__TYPE_IS_LL(t) && sizeof(t) > sizeof(long))
 
@@ -240,18 +246,19 @@ static inline int is_syscall_trace_event(struct trace_event_call *tp_event)
 	__diag_push();							\
 	__diag_ignore(GCC, 8, "-Wattribute-alias",			\
 		      "Type aliasing is used to sanitize syscall arguments");\
-	asmlinkage long sys##name(__MAP(x,__SC_DECL,__VA_ARGS__))	\
-		__attribute__((alias(__stringify(__se_sys##name))));	\
 	ALLOW_ERROR_INJECTION(sys##name, ERRNO);			\
 	static inline long __do_sys##name(__MAP(x,__SC_DECL,__VA_ARGS__));\
-	asmlinkage long __se_sys##name(__MAP(x,__SC_LONG,__VA_ARGS__));	\
-	asmlinkage long __se_sys##name(__MAP(x,__SC_LONG,__VA_ARGS__))	\
+	static inline asmlinkage long __se_sys##name(__MAP(x,__SC_LONG,__VA_ARGS__))    \
 	{								\
 		long ret = __do_sys##name(__MAP(x,__SC_CAST,__VA_ARGS__));\
 		__MAP(x,__SC_TEST,__VA_ARGS__);				\
 		__PROTECT(x, ret,__MAP(x,__SC_ARGS,__VA_ARGS__));	\
 		return ret;						\
 	}								\
+	asmlinkage long sys##name(__MAP(x,__SC_DECL,__VA_ARGS__))       \
+	{                                                               \
+		return __se_sys##name(__MAP(x,__SC_WRAP,__VA_ARGS__));  \
+	}                                                               \
 	__diag_pop();							\
 	static inline long __do_sys##name(__MAP(x,__SC_DECL,__VA_ARGS__))
 #endif /* __SYSCALL_DEFINEx */
diff --git a/kernel/bpf/core.c b/kernel/bpf/core.c
index 44abf88e1..bf6c48e86 100644
--- a/kernel/bpf/core.c
+++ b/kernel/bpf/core.c
@@ -1071,6 +1071,10 @@ void bpf_jit_binary_free(struct bpf_binary_header *hdr)
 	bpf_jit_uncharge_modmem(size);
 }
 
+#ifdef CONFIG_PAX_RAP
+extern long __rap_hash___bpf_prog_run;
+#endif
+
 /* Allocate jit binary from bpf_prog_pack allocator.
  * Since the allocated memory is RO+X, the JIT engine cannot write directly
  * to the memory. To solve this problem, a RW buffer is also allocated at
@@ -1117,11 +1121,24 @@ bpf_jit_binary_pack_alloc(unsigned int proglen, u8 **image_ptr,
 
 	hole = min_t(unsigned int, size - (proglen + sizeof(*ro_header)),
 		     BPF_PROG_CHUNK_SIZE - sizeof(*ro_header));
+#ifdef CONFIG_PAX_RAP
+	hole -= 6;
+#endif
 	start = prandom_u32_max(hole) & ~(alignment - 1);
+#ifdef CONFIG_PAX_RAP
+	start += 6;
+#endif
 
 	*image_ptr = &ro_header->image[start];
 	*rw_image = &(*rw_header)->image[start];
 
+#ifdef CONFIG_PAX_RAP
+#ifdef CONFIG_RELOCATABLE
+	*(int *)(*rw_image - 6) = 0x456bce13;
+#else
+	*(int *)(*rw_image - 6) = (int)&__rap_hash___bpf_prog_run;
+#endif
+#endif
 	return ro_header;
 }
 
@@ -1649,7 +1666,7 @@ bool bpf_opcode_in_insntable(u8 code)
 }
 
 #ifndef CONFIG_BPF_JIT_ALWAYS_ON
-u64 __weak bpf_probe_read_kernel(void *dst, u32 size, const void *unsafe_ptr)
+u64 __weak bpf_probe_read_kernel_alt(void *dst, u32 size, const void *unsafe_ptr)
 {
 	memset(dst, 0, size);
 	return -EFAULT;
@@ -1948,7 +1965,7 @@ static u64 ___bpf_prog_run(u64 *regs, const struct bpf_insn *insn)
 		DST = *(SIZE *)(unsigned long) (SRC + insn->off);	\
 		CONT;							\
 	LDX_PROBE_MEM_##SIZEOP:						\
-		bpf_probe_read_kernel(&DST, sizeof(SIZE),		\
+		bpf_probe_read_kernel_alt(&DST, sizeof(SIZE),		\
 				      (const void *)(long) (SRC + insn->off));	\
 		DST = *((SIZE *)&DST);					\
 		CONT;
diff --git a/kernel/events/core.c b/kernel/events/core.c
index 872d149b1..9add3564f 100644
--- a/kernel/events/core.c
+++ b/kernel/events/core.c
@@ -1112,8 +1112,9 @@ static void __perf_mux_hrtimer_init(struct perf_cpu_context *cpuctx, int cpu)
 	timer->function = perf_mux_hrtimer_handler;
 }
 
-static int perf_mux_hrtimer_restart(struct perf_cpu_context *cpuctx)
+static int perf_mux_hrtimer_restart(void *_cpuctx)
 {
+	struct perf_cpu_context *cpuctx = _cpuctx;
 	struct hrtimer *timer = &cpuctx->hrtimer;
 	struct pmu *pmu = cpuctx->ctx.pmu;
 	unsigned long flags;
diff --git a/kernel/module/main.c b/kernel/module/main.c
index 554aba47a..1a4a78adf 100644
--- a/kernel/module/main.c
+++ b/kernel/module/main.c
@@ -1959,8 +1959,15 @@ static int setup_load_info(struct load_info *info, int flags)
 static int check_modinfo(struct module *mod, struct load_info *info, int flags)
 {
 	const char *modmagic = get_modinfo(info, "vermagic");
+	const char *license = get_modinfo(info, "license");
 	int err;
 
+#if defined(CONFIG_PAX_KERNEXEC_PLUGIN_METHOD_OR) || defined(CONFIG_PAX_RAP)
+	if (!license || !license_is_gpl_compatible(license)) {
+		pr_err("%s: module is not compatible with the KERNEXEC 'or' method and RAP\n", mod->name);
+		return -ENOEXEC;
+	}
+#endif
 	if (flags & MODULE_INIT_IGNORE_VERMAGIC)
 		modmagic = NULL;
 
@@ -1995,7 +2002,7 @@ static int check_modinfo(struct module *mod, struct load_info *info, int flags)
 		return err;
 
 	/* Set up license info based on the info section */
-	set_license(mod, get_modinfo(info, "license"));
+	set_license(mod, license);
 
 	if (get_modinfo(info, "test")) {
 		if (!test_taint(TAINT_TEST))
diff --git a/kernel/sched/core.c b/kernel/sched/core.c
index 18a4f8f28..5c4bb23d4 100644
--- a/kernel/sched/core.c
+++ b/kernel/sched/core.c
@@ -4885,7 +4885,7 @@ static void do_balance_callbacks(struct rq *rq, struct balance_callback *head)
 	lockdep_assert_rq_held(rq);
 
 	while (head) {
-		func = (void (*)(struct rq *))head->func;
+		func = head->func;
 		next = head->next;
 		head->next = NULL;
 		head = next;
diff --git a/net/bridge/br_private.h b/net/bridge/br_private.h
index 940de9516..dfeaefa75 100644
--- a/net/bridge/br_private.h
+++ b/net/bridge/br_private.h
@@ -869,7 +869,8 @@ void br_del_frame(struct net_bridge *br, struct br_frame_type *ft);
 
 static inline bool br_rx_handler_check_rcu(const struct net_device *dev)
 {
-	return rcu_dereference(dev->rx_handler) == br_get_rx_handler(dev);
+	//return rcu_dereference(dev->rx_handler) == br_get_rx_handler(dev);
+	return br_get_rx_handler(dev) == rcu_dereference(dev->rx_handler);
 }
 
 static inline bool br_rx_handler_check_rtnl(const struct net_device *dev)
diff --git a/net/netfilter/ipset/ip_set_core.c b/net/netfilter/ipset/ip_set_core.c
index f645da82d..0e82af111 100644
--- a/net/netfilter/ipset/ip_set_core.c
+++ b/net/netfilter/ipset/ip_set_core.c
@@ -391,7 +391,6 @@ ip_set_comment_free(struct ip_set *set, void *ptr)
 	rcu_assign_pointer(comment->c, NULL);
 }
 
-typedef void (*destroyer)(struct ip_set *, void *);
 /* ipset data extension types, in size order */
 
 const struct ip_set_ext_type ip_set_extensions[] = {
diff --git a/scripts/Makefile.gcc-plugins b/scripts/Makefile.gcc-plugins
index e4deaf5fa..7acd78f9d 100644
--- a/scripts/Makefile.gcc-plugins
+++ b/scripts/Makefile.gcc-plugins
@@ -22,6 +22,14 @@ export DISABLE_STRUCTLEAK_PLUGIN
 gcc-plugin-cflags-$(CONFIG_GCC_PLUGIN_STRUCTLEAK)		\
 		+= -DSTRUCTLEAK_PLUGIN
 
+gcc-plugin-$(CONFIG_PAX_RAP)                           += rap_plugin.so
+gcc-plugin-cflags-$(CONFIG_PAX_RAP)                    += -DRAP_PLUGIN -fplugin-arg-rap_plugin-check=call -fplugin-arg-rap_plugin-hash=abs-finish
+# gcc-plugin-cflags-$(CONFIG_PAX_RAP)                  += -fplugin-arg-rap_plugin-report=func,fptr,abs
+ifdef CONFIG_PAX_RAP
+  RAP_PLUGIN_ABS_CFLAGS                                := -fplugin-arg-rap_plugin-hash=abs-finish
+endif
+gcc-plugin-aflags-$(CONFIG_PAX_RAP)                    += -DRAP_PLUGIN
+
 gcc-plugin-$(CONFIG_GCC_PLUGIN_STACKLEAK)	+= stackleak_plugin.so
 gcc-plugin-cflags-$(CONFIG_GCC_PLUGIN_STACKLEAK)		\
 		+= -DSTACKLEAK_PLUGIN
@@ -47,8 +55,12 @@ export DISABLE_ARM_SSP_PER_TASK_PLUGIN
 GCC_PLUGINS_CFLAGS := $(strip $(addprefix -fplugin=$(objtree)/scripts/gcc-plugins/, $(gcc-plugin-y)) $(gcc-plugin-cflags-y))
 export GCC_PLUGINS_CFLAGS
 
+GCC_PLUGINS_AFLAGS := $(gcc-plugin-aflags-y)
+export RAP_PLUGIN_ABS_CFLAGS GCC_PLUGINS_AFLAGS
+
 # Add the flags to the build!
 KBUILD_CFLAGS += $(GCC_PLUGINS_CFLAGS)
+KBUILD_AFLAGS += $(GCC_PLUGINS_AFLAGS)
 
 # Some plugins are enabled outside of this Makefile, but they still need to
 # be included in GCC_PLUGIN so they can get built.
diff --git a/scripts/gcc-plugins/Makefile b/scripts/gcc-plugins/Makefile
index 320afd3cf..6246b5bdf 100644
--- a/scripts/gcc-plugins/Makefile
+++ b/scripts/gcc-plugins/Makefile
@@ -36,11 +36,13 @@ plugin_cxxflags	= -Wp,-MMD,$(depfile) $(KBUILD_HOSTCXXFLAGS) -fPIC \
 
 plugin_ldflags	= -shared
 
+rap_plugin-objs := $(patsubst $(srctree)/$(src)/rap_plugin/%.c,rap_plugin/%.o,$(wildcard $(srctree)/$(src)/rap_plugin/*.c))
+
 plugin-single	:= $(foreach m, $(GCC_PLUGIN), $(if $($(m:%.so=%-objs)),,$(m)))
 plugin-multi	:= $(filter-out $(plugin-single), $(GCC_PLUGIN))
 plugin-objs	:= $(sort $(foreach m, $(plugin-multi), $($(m:%.so=%-objs))))
-
 targets += $(plugin-single) $(plugin-multi) $(plugin-objs)
+
 clean-files += *.so
 
 plugin-single	:= $(addprefix $(obj)/, $(plugin-single))
diff --git a/scripts/gcc-plugins/rap_plugin/rap.h b/scripts/gcc-plugins/rap_plugin/rap.h
new file mode 100644
index 000000000..dbaafeed7
--- /dev/null
+++ b/scripts/gcc-plugins/rap_plugin/rap.h
@@ -0,0 +1,38 @@
+#ifndef RAP_H_INCLUDED
+#define RAP_H_INCLUDED
+
+#include "gcc-common.h"
+
+#define RAP_HASH_START_PADDING_SIZE  3
+#define RAP_HASH_END_PADDING_SIZE  2
+typedef struct {
+	int hash; // will be sign extended to long in reality
+} rap_hash_t;
+
+typedef struct {
+	unsigned int qual_const:1;
+	unsigned int qual_volatile:1;
+} rap_hash_flags_t;
+extern rap_hash_flags_t imprecise_rap_hash_flags;
+
+extern bool report_fptr_hash;
+
+extern GTY(()) tree rap_hash_type_node;
+
+void siphash24fold(unsigned char *out, const unsigned char *in, unsigned long long inlen, const unsigned char *k);
+void rap_calculate_func_hashes(void *event_data, void *data);
+rap_hash_t rap_hash_function_type(const_tree fntype, rap_hash_flags_t flags);
+rap_hash_t rap_hash_function_decl(const_tree fndecl, rap_hash_flags_t flags);
+rap_hash_t rap_hash_function_node_imprecise(cgraph_node_ptr node);
+const_tree type_name(const_tree type);
+tree create_new_var(tree type, const char *name);
+
+gimple barrier(tree var, bool full);
+
+#if BUILDING_GCC_VERSION >= 4009
+opt_pass *make_rap_fptr_pass(void);
+#else
+struct opt_pass *make_rap_fptr_pass(void);
+#endif
+
+#endif
diff --git a/scripts/gcc-plugins/rap_plugin/rap_fptr_pass.c b/scripts/gcc-plugins/rap_plugin/rap_fptr_pass.c
new file mode 100644
index 000000000..511076ab2
--- /dev/null
+++ b/scripts/gcc-plugins/rap_plugin/rap_fptr_pass.c
@@ -0,0 +1,224 @@
+/*
+ * Copyright 2012-2016 by PaX Team <pageexec@freemail.hu>
+ * Licensed under the GPL v2
+ *
+ * Homepage: http://pax.grsecurity.net/
+ */
+
+#include "rap.h"
+
+bool report_fptr_hash;
+
+static bool rap_fptr_gate(void)
+{
+#ifdef TARGET_64BIT
+	tree section;
+
+	if (!TARGET_64BIT || ix86_cmodel != CM_KERNEL)
+		return true;
+
+	section = lookup_attribute("section", DECL_ATTRIBUTES(current_function_decl));
+	if (!section || !TREE_VALUE(section))
+		return true;
+
+	section = TREE_VALUE(TREE_VALUE(section));
+	return strncmp(TREE_STRING_POINTER(section), ".vsyscall_", 10);
+#else
+#error unsupported target
+#endif
+}
+
+static tree build_rap_hash(gimple call_stmt, tree fntype)
+{
+	rap_hash_t hash;
+
+	hash = rap_hash_function_type(fntype, imprecise_rap_hash_flags);
+	if (report_fptr_hash)
+		inform(gimple_location(call_stmt), "fptr rap_hash: %x", hash.hash);
+	return build_int_cst_type(rap_hash_type_node, hash.hash);
+}
+
+// check the function hash of the target of the fptr
+static basic_block rap_instrument_fptr(gimple_stmt_iterator *gsi)
+{
+	gimple assign_hash, check_hash, call_stmt, stmt;
+	location_t loc;
+	tree computed_hash, target_hash, fptr, fntype;
+#if BUILDING_GCC_VERSION == 4005
+	tree fptr2;
+#endif
+	basic_block cond_bb, join_bb, true_bb;
+	edge e;
+	const HOST_WIDE_INT rap_hash_offset = sizeof(rap_hash_t) + 2;
+
+	call_stmt = gsi_stmt(*gsi);
+	loc = gimple_location(call_stmt);
+	fptr = gimple_call_fn(call_stmt);
+	fntype = TREE_TYPE(TREE_TYPE(fptr));
+
+	if (TREE_CODE(fntype) == FUNCTION_TYPE) {
+		computed_hash = build_rap_hash(call_stmt, fntype);
+	} else {
+		debug_tree(fntype);
+		gcc_unreachable();
+	}
+
+	// target_hash = ((s64*)fptr)[-rap_hash_offset]
+	target_hash = create_tmp_var(rap_hash_type_node, "rap_hash");
+	add_referenced_var(target_hash);
+	target_hash = make_ssa_name(target_hash, NULL);
+#if BUILDING_GCC_VERSION == 4005
+	fptr2 = create_tmp_var(ptr_type_node, "rap_fptr2");
+	fptr2 = make_ssa_name(fptr2, NULL);
+	assign_hash = gimple_build_assign(fptr2, build2(POINTER_PLUS_EXPR, ptr_type_node, fptr, build_int_cst_type(sizetype, -rap_hash_offset)));
+	gimple_set_location(assign_hash, loc);
+	SSA_NAME_DEF_STMT(fptr2) = assign_hash;
+	gsi_insert_before(gsi, assign_hash, GSI_SAME_STMT);
+	update_stmt(assign_hash);
+	fptr = gimple_get_lhs(assign_hash);
+
+	fptr2 = create_tmp_var(build_pointer_type(rap_hash_type_node), "rap_fptr2");
+	fptr2 = make_ssa_name(fptr2, NULL);
+	assign_hash = gimple_build_assign(fptr2, fold_convert(build_pointer_type(TREE_TYPE(target_hash)), fptr));
+	gimple_set_location(assign_hash, loc);
+	SSA_NAME_DEF_STMT(fptr2) = assign_hash;
+	gsi_insert_before(gsi, assign_hash, GSI_SAME_STMT);
+	update_stmt(assign_hash);
+	fptr = gimple_get_lhs(assign_hash);
+
+	assign_hash = gimple_build_assign(target_hash, build1(INDIRECT_REF, rap_hash_type_node, fptr));
+#else
+	assign_hash = gimple_build_assign(target_hash, build2(MEM_REF, integer_type_node, fptr, build_int_cst_type(build_pointer_type(rap_hash_type_node), -rap_hash_offset)));
+#endif
+	gimple_set_location(assign_hash, loc);
+	SSA_NAME_DEF_STMT(target_hash) = assign_hash;
+	gsi_insert_before(gsi, assign_hash, GSI_NEW_STMT);
+	update_stmt(assign_hash);
+
+	// compare target_hash against computed function hash
+	// bail out on mismatch
+	check_hash = gimple_build_cond(NE_EXPR, target_hash, computed_hash, NULL_TREE, NULL_TREE);
+	gimple_set_location(check_hash, loc);
+	gsi_insert_after(gsi, check_hash, GSI_NEW_STMT);
+
+	cond_bb = gimple_bb(gsi_stmt(*gsi));
+	gcc_assert(!gsi_end_p(*gsi));
+	gcc_assert(check_hash == gsi_stmt(*gsi));
+
+	e = split_block(cond_bb, gsi_stmt(*gsi));
+	cond_bb = e->src;
+	join_bb = e->dest;
+	e->flags = EDGE_FALSE_VALUE;
+#if BUILDING_GCC_VERSION < 8000
+	e->probability = REG_BR_PROB_BASE;
+#else
+	e->probability = profile_probability::always ();
+#endif
+
+	true_bb = create_empty_bb(EXIT_BLOCK_PTR_FOR_FN(cfun)->prev_bb);
+	make_edge(cond_bb, true_bb, EDGE_TRUE_VALUE | EDGE_PRESERVE);
+
+	gcc_assert(dom_info_available_p(CDI_DOMINATORS));
+	set_immediate_dominator(CDI_DOMINATORS, true_bb, cond_bb);
+	set_immediate_dominator(CDI_DOMINATORS, join_bb, cond_bb);
+
+	gcc_assert(cond_bb->loop_father == join_bb->loop_father);
+	add_bb_to_loop(true_bb, cond_bb->loop_father);
+
+	*gsi = gsi_start_bb(true_bb);
+
+	// this fake dependency is to prevent PRE from merging this BB with others of the same kind
+	stmt = barrier(fptr, false);
+	gimple_set_location(stmt, loc);
+	gsi_insert_after(gsi, stmt, GSI_CONTINUE_LINKING);
+
+	stmt = gimple_build_call(builtin_decl_implicit(BUILT_IN_TRAP), 0);
+	gimple_set_location(stmt, loc);
+	gsi_insert_after(gsi, stmt, GSI_CONTINUE_LINKING);
+
+	return join_bb;
+}
+
+// find all language level function pointer dereferences and verify the target function
+static unsigned int rap_fptr_execute(void)
+{
+	basic_block bb;
+
+	loop_optimizer_init(LOOPS_NORMAL | LOOPS_HAVE_RECORDED_EXITS);
+	gcc_assert(current_loops);
+
+	calculate_dominance_info(CDI_DOMINATORS);
+	calculate_dominance_info(CDI_POST_DOMINATORS);
+
+	// 1. loop through BBs and GIMPLE statements
+	FOR_EACH_BB_FN(bb, cfun) {
+		gimple_stmt_iterator gsi;
+
+		for (gsi = gsi_start_bb(bb); !gsi_end_p(gsi); gsi_next(&gsi)) {
+			// gimple match: h_1 = get_fptr (); D.2709_3 = h_1 (x_2(D));
+			tree fptr, fntype;
+			gimple call_stmt;
+
+			// is it a call ...
+			call_stmt = gsi_stmt(gsi);
+			if (!is_gimple_call(call_stmt))
+				continue;
+
+			fptr = gimple_call_fn(call_stmt);
+			if (!fptr)
+				continue;
+
+			switch (TREE_CODE(fptr)) {
+			default:
+				debug_gimple_stmt(call_stmt);
+				debug_tree(fptr);
+				debug_tree(TREE_TYPE(fptr));
+				gcc_unreachable();
+
+			case ADDR_EXPR:
+				continue;
+
+			case SSA_NAME:
+				if (SSA_NAME_VAR(fptr) == NULL_TREE)
+					break;
+
+				switch (TREE_CODE(SSA_NAME_VAR(fptr))) {
+				default:
+					debug_gimple_stmt(call_stmt);
+					debug_tree(fptr);
+					gcc_unreachable();
+
+				case VAR_DECL:
+				case PARM_DECL:
+					break;
+				}
+				break;
+
+			case INTEGER_CST:
+			case OBJ_TYPE_REF:
+				break;
+			}
+
+			// ... through a function pointer
+			fntype = TREE_TYPE(fptr);
+			if (TREE_CODE(fntype) != POINTER_TYPE)
+				continue;
+
+			fntype = TREE_TYPE(fntype);
+			gcc_assert(TREE_CODE(fntype) == FUNCTION_TYPE || TREE_CODE(fntype) == METHOD_TYPE);
+
+			bb = rap_instrument_fptr(&gsi);
+			gsi = gsi_start_bb(bb);
+		}
+	}
+
+	free_dominance_info(CDI_DOMINATORS);
+	free_dominance_info(CDI_POST_DOMINATORS);
+	loop_optimizer_finalize();
+
+	return 0;
+}
+
+#define PASS_NAME rap_fptr
+#define TODO_FLAGS_FINISH TODO_verify_ssa | TODO_verify_stmts | TODO_dump_func | TODO_remove_unused_locals | TODO_update_ssa | TODO_cleanup_cfg | TODO_rebuild_cgraph_edges | TODO_verify_flow
+#include "gcc-generate-gimple-pass.h"
diff --git a/scripts/gcc-plugins/rap_plugin/rap_hash.c b/scripts/gcc-plugins/rap_plugin/rap_hash.c
new file mode 100644
index 000000000..420fcbdbf
--- /dev/null
+++ b/scripts/gcc-plugins/rap_plugin/rap_hash.c
@@ -0,0 +1,396 @@
+/*
+ * Copyright 2012-2016 by PaX Team <pageexec@freemail.hu>
+ * Licensed under the GPL v2
+ *
+ * Homepage: http://pax.grsecurity.net/
+ */
+
+#include "rap.h"
+
+static rap_hash_t *rap_imprecise_hashes;
+static int rap_cgraph_max_uid;
+
+static void rap_hash_function(const_tree fntype, rap_hash_flags_t flags, unsigned char sip_hash[8]);
+
+static const unsigned char rap_hash_tree_code[MAX_TREE_CODES] = {
+	[0] = 0,
+	[1] = 0,
+	[2] = 0,
+	[3] = 0,
+	[4] = 0,
+	[OFFSET_TYPE] = 10,
+	[ENUMERAL_TYPE] = 20,
+	[BOOLEAN_TYPE] = 30,
+	[INTEGER_TYPE] = 40,
+	[REAL_TYPE] = 50,
+	[POINTER_TYPE] = 60,
+	[REFERENCE_TYPE] = 70,
+#if BUILDING_GCC_VERSION >= 4006
+	[NULLPTR_TYPE] = 80,
+#endif
+	[FIXED_POINT_TYPE] = 0,
+	[COMPLEX_TYPE] = 100,
+	[VECTOR_TYPE] = 110,
+	[ARRAY_TYPE] = 120,
+	[RECORD_TYPE] = 130,
+	[UNION_TYPE] = 140,
+	[QUAL_UNION_TYPE] = 0,
+	[VOID_TYPE] = 160,
+#if BUILDING_GCC_VERSION >= 5000 && BUILDING_GCC_VERSION < 9000
+	[POINTER_BOUNDS_TYPE] = 170,
+#endif
+	[FUNCTION_TYPE] = 180,
+	[METHOD_TYPE] = 0,
+	[LANG_TYPE] = 0,
+};
+
+static void rap_fold_hash(unsigned char *out, const unsigned char *in, unsigned long long inlen)
+{
+	static const unsigned char rap_sip_key[16] = {
+		'P', 'a', 'X', ' ', 'T', 'e', 'a', 'm',
+		'R', 'A', 'P', ' ', 'H', 'A', 'S', 'H',
+	};
+
+	siphash24fold(out, in, inlen, rap_sip_key);
+}
+
+// compute the final hash value in the range [1,INT_MAX]
+// the % and +1 trick leaves the value 0 available for marking non-indirectly callable functions
+// and INT_MIN (0x80000000) for longjmp targets (sign extended)
+// return places will use the (sign extended) range [INT_MIN+1,-1] ([0x8000001,0xffffffff])
+static rap_hash_t rap_extract_hash(const unsigned char sip_hash[8])
+{
+	rap_hash_t hash;
+	unsigned long long dividend, divisor;
+
+	memcpy(&dividend, sip_hash, sizeof dividend);
+//	divisor = 1ULL << (sizeof hash * 8 - 1);
+//	divisor |= divisor - 1;
+	divisor = 0x7fffffffUL;
+	hash.hash = dividend % divisor + 1;
+	return hash;
+}
+
+static void rap_hash_type_name(const_tree type, unsigned char sip_hash[8])
+{
+	const_tree name = type_name(TYPE_MAIN_VARIANT(type));
+
+	// handle typedefs of anonymous structs/unions
+	if (name == NULL_TREE)
+		name = type_name(type);
+
+	if (name == NULL_TREE)
+		return;
+
+	gcc_assert(TREE_CODE(name) == IDENTIFIER_NODE);
+	rap_fold_hash(sip_hash, (const unsigned char *)IDENTIFIER_POINTER(name), IDENTIFIER_LENGTH(name));
+}
+
+static void rap_hash_type_precision(const_tree type, unsigned char sip_hash[8])
+{
+	unsigned HOST_WIDE_INT size;
+
+	gcc_assert(TYPE_PRECISION(type));
+
+	size = TYPE_PRECISION(type);
+	rap_fold_hash(sip_hash, (const unsigned char *)&size, sizeof size);
+}
+
+const_tree type_name(const_tree type)
+{
+	const_tree name;
+
+	name = TYPE_NAME(type);
+	if (!name)
+		return NULL_TREE;
+
+	switch (TREE_CODE(name)) {
+	case IDENTIFIER_NODE:
+		return name;
+
+	case TYPE_DECL:
+		gcc_assert(DECL_NAME(name));
+		return DECL_NAME(name);
+
+	default:
+		gcc_unreachable();
+	}
+}
+
+__attribute__((weak)) tree c_global_trees[CTI_MAX];
+
+// the core computation of the rap hash
+// the first piece is a (hopefully) compiler independent encondig of the type, derived from the gcc tree code
+// the second piece is type specific information, such as the size, qualifiers, (recursively) referenced types, etc
+static void rap_hash_tree(const_tree type, rap_hash_flags_t flags, unsigned char sip_hash[8])
+{
+	enum tree_code code;
+	unsigned int attrs;
+
+	code = TREE_CODE(type);
+	attrs = rap_hash_tree_code[code];
+	if (!attrs) {
+		fprintf(stderr, "unhandled tree_code %s %d\n", get_tree_code_name(code), code);
+		debug_tree(type);
+		gcc_unreachable();
+	}
+	rap_fold_hash(sip_hash, (const unsigned char *)&attrs, sizeof attrs);
+
+	enum {
+	// attrs layout for
+		// - all types:
+		RAP_HASH_VOLATILE		= 1U << 31,
+		RAP_HASH_NOT_VOLATILE		= 1U << 30,
+		RAP_HASH_CONST			= 1U << 29,
+		RAP_HASH_NOT_CONST		= 1U << 28,
+
+		// - pointer types:
+		RAP_HASH_RESTRICT		= 1U << 27,
+		RAP_HASH_NOT_RESTRICT		= 1U << 26,
+
+		// - C integer types:
+		RAP_HASH_UNSIGNED		= 1U << 25,
+		RAP_HASH_SIGNED			= 1U << 24,
+
+		RAP_HASH_UNQUALIFIED_CHAR	= 1U << 23,
+		RAP_HASH_CHAR			= 1U << 22,
+		RAP_HASH_SHORT			= 1U << 21,
+		RAP_HASH_INT			= 1U << 20,
+		RAP_HASH_LONG			= 1U << 19,
+		RAP_HASH_LONG_LONG		= 1U << 18,
+		RAP_HASH_WCHAR			= 1U << 17,
+		RAP_HASH_CHAR16			= 1U << 16,
+		RAP_HASH_CHAR32			= 1U << 15,
+
+		// - C float types
+		RAP_HASH_FLOAT			= 1U << 14,
+		RAP_HASH_DOUBLE			= 1U << 13,
+		RAP_HASH_LONG_DOUBLE		= 1U << 12,
+		RAP_HASH_DFLOAT32		= 1U << 11,
+		RAP_HASH_DFLOAT64		= 1U << 10,
+		RAP_HASH_DFLOAT128		= 1U << 9,
+	};
+
+	attrs = 0;
+	if (flags.qual_volatile)
+		attrs |= TYPE_VOLATILE(type) ? RAP_HASH_VOLATILE : RAP_HASH_NOT_VOLATILE;
+	if (flags.qual_const)
+		attrs |= TYPE_READONLY(type) ? RAP_HASH_CONST : RAP_HASH_NOT_CONST;
+
+	switch (code) {
+	default:
+		debug_tree(type);
+		gcc_unreachable();
+		break;
+
+	case VOID_TYPE:
+		break;
+
+	case OFFSET_TYPE:
+		rap_hash_tree(TREE_TYPE(type), flags, sip_hash);
+		rap_hash_tree(TYPE_OFFSET_BASETYPE(type), flags, sip_hash);
+		break;
+
+	case FUNCTION_TYPE:
+		rap_hash_function(type, flags, sip_hash);
+		break;
+
+	case RECORD_TYPE:
+		rap_hash_type_name(type, sip_hash);
+		break;
+
+	case UNION_TYPE:
+		rap_hash_type_name(type, sip_hash);
+		break;
+
+	case POINTER_TYPE:
+	case REFERENCE_TYPE:
+		rap_hash_tree(TREE_TYPE(type), flags, sip_hash);
+		break;
+
+	case VECTOR_TYPE:
+		rap_hash_tree(TREE_TYPE(type), flags, sip_hash);
+		rap_hash_type_precision(TREE_TYPE(type), sip_hash);
+		break;
+
+	case ARRAY_TYPE:
+		rap_hash_tree(TREE_TYPE(type), flags, sip_hash);
+		break;
+
+	case REAL_TYPE: {
+		const_tree main_variant = TYPE_MAIN_VARIANT(type);
+
+		switch (TYPE_PRECISION(main_variant)) {
+		default:
+			debug_tree(type);
+			debug_tree(TYPE_MAIN_VARIANT(type));
+			gcc_unreachable();
+
+		case 32:
+//			attrs |= RAP_HASH_FLOAT;
+			break;
+
+		case 64:
+//			attrs |= RAP_HASH_DOUBLE;
+			break;
+
+		case 80:
+		case 128:
+			attrs |= RAP_HASH_LONG_DOUBLE;
+			break;
+		}
+		rap_hash_type_precision(main_variant, sip_hash);
+		break;
+	}
+
+	case ENUMERAL_TYPE:
+		rap_hash_type_name(type, sip_hash);
+	case BOOLEAN_TYPE:
+		rap_hash_type_precision(type, sip_hash);
+		break;
+
+	case INTEGER_TYPE: {
+		attrs |= TYPE_UNSIGNED(type) ? RAP_HASH_UNSIGNED : RAP_HASH_SIGNED;
+		rap_hash_type_precision(type, sip_hash);
+		break;
+	}
+	}
+
+	rap_fold_hash(sip_hash, (const unsigned char *)&attrs, sizeof attrs);
+}
+
+static const_tree rap_dequal_argtype(const_tree argtype)
+{
+	// since gcc/tree.c:free_lang_data_in_type removes const/volatile from the top level param decl
+	// we have to simulate it here as this can be called earlier from the frontend as well
+	if (TYPE_READONLY(argtype) || TYPE_VOLATILE(argtype)) {
+		int quals;
+
+		quals = TYPE_QUALS(argtype) & ~TYPE_QUAL_CONST & ~TYPE_QUAL_VOLATILE;
+		argtype = build_qualified_type(CONST_CAST_TREE(argtype), quals);
+	}
+
+	return argtype;
+}
+
+// main function to compute the rap hash for function types
+// while virtual class methods are always replaced with their ancestor,
+// callers can decide whether to fully utilize that information via flags.method_ancestor
+static void rap_hash_function(const_tree fntype, rap_hash_flags_t flags, unsigned char sip_hash[8])
+{
+	function_args_iterator args_iter;
+	const_tree arg;
+
+	switch (TREE_CODE(fntype)) {
+	default:
+		debug_tree(fntype);
+		gcc_unreachable();
+
+	case FUNCTION_TYPE:
+		// 1. hash the result
+		rap_hash_tree(TREE_TYPE(fntype), flags, sip_hash);
+
+		// 2. hash the function parameters
+		FOREACH_FUNCTION_ARGS(fntype, arg, args_iter) {
+			const_tree argtype = arg;
+
+			argtype = rap_dequal_argtype(argtype);
+			rap_hash_tree(argtype, flags, sip_hash);
+		}
+		break;
+	}
+}
+
+rap_hash_t rap_hash_function_type(const_tree fntype, rap_hash_flags_t flags)
+{
+	unsigned char sip_hash[8] = { };
+	rap_hash_t hash;
+
+	rap_hash_function(fntype, flags, sip_hash);
+	hash = rap_extract_hash(sip_hash);
+
+	gcc_assert(hash.hash);
+	return hash;
+}
+
+rap_hash_t rap_hash_function_decl(const_tree fndecl, rap_hash_flags_t flags)
+{
+	tree fntype;
+
+	gcc_assert(TREE_CODE(fndecl) == FUNCTION_DECL);
+	fntype = TREE_TYPE(fndecl);
+
+	switch (TREE_CODE(fntype)) {
+	default:
+		debug_tree(fndecl);
+		gcc_unreachable();
+
+	case FUNCTION_TYPE:
+		return rap_hash_function_type(fntype, flags);
+	}
+}
+
+rap_hash_t rap_hash_function_node_imprecise(cgraph_node_ptr node)
+{
+	rap_hash_t hash;
+	tree fndecl;
+	int uid;
+
+	gcc_assert(rap_imprecise_hashes);
+
+	hash.hash = 0;
+#if BUILDING_GCC_VERSION < 9003
+	uid = node->uid;
+#else
+	uid = node->get_uid();
+#endif
+	if (uid < rap_cgraph_max_uid)
+		hash = rap_imprecise_hashes[uid];
+
+	if (hash.hash)
+		return hash;
+
+	fndecl = NODE_DECL(node);
+	if (TREE_CODE(TREE_TYPE(fndecl)) == FUNCTION_TYPE)
+		return rap_hash_function_decl(fndecl, imprecise_rap_hash_flags);
+
+	debug_cgraph_node(node);
+	debug_tree(fndecl);
+	error("indirect call to function %qD with a reserved hash value", fndecl);
+	return hash;
+}
+
+void rap_calculate_func_hashes(void *event_data __unused, void *data __unused)
+{
+	cgraph_node_ptr node;
+	int uid;
+
+	gcc_assert(!rap_imprecise_hashes);
+
+	rap_imprecise_hashes = (rap_hash_t *)xcalloc(cgraph_max_uid, sizeof(*rap_imprecise_hashes));
+	rap_cgraph_max_uid = cgraph_max_uid;
+
+	FOR_EACH_FUNCTION(node) {
+		const_tree fndecl;
+
+#if BUILDING_GCC_VERSION < 9003
+		uid = node->uid;
+#else
+		uid = node->get_uid();
+#endif
+		gcc_assert(uid < rap_cgraph_max_uid);
+
+#if BUILDING_GCC_VERSION < 10000
+		if (node->global.inlined_to)
+#else
+		if (node->inlined_to)
+#endif
+			continue;
+
+		fndecl = NODE_DECL(node);
+		gcc_assert(fndecl);
+
+		rap_imprecise_hashes[uid] = rap_hash_function_decl(fndecl, imprecise_rap_hash_flags);
+		gcc_assert(rap_imprecise_hashes[uid].hash);
+	}
+}
diff --git a/scripts/gcc-plugins/rap_plugin/rap_plugin.c b/scripts/gcc-plugins/rap_plugin/rap_plugin.c
new file mode 100644
index 000000000..963960c56
--- /dev/null
+++ b/scripts/gcc-plugins/rap_plugin/rap_plugin.c
@@ -0,0 +1,553 @@
+/*
+ * Copyright 2012-2016 by PaX Team <pageexec@freemail.hu>
+ * Licensed under the GPL v2
+ *
+ * Homepage: http://pax.grsecurity.net/
+ *
+ * Usage:
+ * $ # for 4.5/4.6/C based 4.7
+ * $ gcc -I`gcc -print-file-name=plugin`/include -I`gcc -print-file-name=plugin`/include/c-family -fPIC -shared -O2 -o rap_plugin.so rap_plugin.c
+ * $ # for C++ based 4.7/4.8+
+ * $ g++ -I`g++ -print-file-name=plugin`/include -I`g++ -print-file-name=plugin`/include/c-family -fPIC -shared -O2 -o rap_plugin.so rap_plugin.c
+ * $ gcc -fplugin=./rap_plugin.so -fplugin-arg-rap_plugin-check=call test.c -O2
+ */
+
+#include "rap.h"
+
+__visible int plugin_is_GPL_compatible;
+
+static struct plugin_info rap_plugin_info = {
+	.version	= "201604272100",
+	.help		= "check=call\tenable the corresponding features\n"
+			  "hash=abs,abs-finish,const,volatile\n"
+			  "report=func,fptr,abs\n"
+};
+
+rap_hash_flags_t imprecise_rap_hash_flags = {
+	.qual_const	= 1,
+	.qual_volatile	= 1,
+};
+
+tree rap_hash_type_node;
+
+static bool report_func_hash, report_abs_hash;
+
+// create the equivalent of
+// asm volatile("" : : : "memory");
+// or
+// asm("" : "+rm"(var));
+// or
+// asm("" : : "rm"(var));
+gimple barrier(tree var, bool full)
+{
+	gimple stmt;
+	gasm *asm_stmt;
+#if BUILDING_GCC_VERSION <= 4007
+	VEC(tree, gc) *inputs = NULL;
+	VEC(tree, gc) *outputs = NULL;
+	VEC(tree, gc) *clobbers = NULL;
+#else
+	vec<tree, va_gc> *inputs = NULL;
+	vec<tree, va_gc> *outputs = NULL;
+	vec<tree, va_gc> *clobbers = NULL;
+#endif
+
+	if (!var && full) {
+		tree clobber;
+
+		clobber = build_tree_list(NULL_TREE, build_string(7, "memory"));
+#if BUILDING_GCC_VERSION <= 4007
+		VEC_safe_push(tree, gc, clobbers, clobber);
+#else
+		vec_safe_push(clobbers, clobber);
+#endif
+	} else if (full) {
+		tree input, output;
+
+		input = build_tree_list(NULL_TREE, build_string(2, "0"));
+		input = chainon(NULL_TREE, build_tree_list(input, var));
+#if BUILDING_GCC_VERSION <= 4007
+		VEC_safe_push(tree, gc, inputs, input);
+#else
+		vec_safe_push(inputs, input);
+#endif
+
+		output = build_tree_list(NULL_TREE, build_string(4, "=rm"));
+		gcc_assert(SSA_NAME_VAR(var));
+		var = make_ssa_name(SSA_NAME_VAR(var), NULL);
+		output = chainon(NULL_TREE, build_tree_list(output, var));
+#if BUILDING_GCC_VERSION <= 4007
+		VEC_safe_push(tree, gc, outputs, output);
+#else
+		vec_safe_push(outputs, output);
+#endif
+	} else {
+		tree input;
+
+		input = build_tree_list(NULL_TREE, build_string(3, "rm"));
+		input = chainon(NULL_TREE, build_tree_list(input, var));
+#if BUILDING_GCC_VERSION <= 4007
+		VEC_safe_push(tree, gc, inputs, input);
+#else
+		vec_safe_push(inputs, input);
+#endif
+	}
+
+	stmt = gimple_build_asm_vec("", inputs, outputs, clobbers, NULL);
+	asm_stmt = as_a_gasm(stmt);
+	if (!var && full)
+		gimple_asm_set_volatile(asm_stmt, true);
+	else if (full)
+		SSA_NAME_DEF_STMT(var) = stmt;
+	return stmt;
+}
+
+static const struct gcc_debug_hooks *old_debug_hooks;
+static struct gcc_debug_hooks rap_debug_hooks;
+
+static bool __rap_cgraph_indirectly_callable(cgraph_node_ptr node, void *data)
+{
+#if BUILDING_GCC_VERSION >= 4008
+	if (NODE_SYMBOL(node)->externally_visible)
+#else
+	if (node->local.externally_visible)
+#endif
+		return true;
+
+	if (NODE_SYMBOL(node)->address_taken)
+		return true;
+
+	return false;
+}
+
+static bool rap_cgraph_indirectly_callable(cgraph_node_ptr node)
+{
+	return cgraph_for_node_and_aliases(node, __rap_cgraph_indirectly_callable, NULL, true);
+}
+
+static void rap_hash_align(tree decl)
+{
+	const unsigned HOST_WIDE_INT rap_hash_offset = TARGET_64BIT ? 2 * sizeof(rap_hash_t) : sizeof(rap_hash_t);
+	unsigned HOST_WIDE_INT skip;
+
+#if BUILDING_GCC_VERSION < 9003
+	skip = 1ULL << align_functions_log;
+#else
+	skip = 1ULL <<  align_functions.levels[0].log;
+#endif
+	if (DECL_USER_ALIGN(decl))
+		return;
+
+	if (!optimize_function_for_speed_p(cfun)) {
+		ASM_OUTPUT_ASCII(asm_out_file, "\xb8", 1);
+		return;
+	}
+
+	if (skip <= rap_hash_offset)
+		return;
+
+#ifdef TARGET_64BIT
+	{
+		char padding[RAP_HASH_START_PADDING_SIZE];
+
+		// this byte sequence helps disassemblers not trip up on the following rap hash
+		memset(padding, 0xcc, sizeof padding - 1);
+		padding[sizeof padding - 1] = 0xb8;
+		ASM_OUTPUT_ASCII(asm_out_file, padding, sizeof padding);
+	}
+#else
+	ASM_OUTPUT_SKIP(asm_out_file, skip - rap_hash_offset);
+#endif
+}
+
+static void rap_begin_function(tree decl)
+{
+	cgraph_node_ptr node;
+	rap_hash_t imprecise_rap_hash;
+	char *name = NULL;
+	char end_padding[RAP_HASH_END_PADDING_SIZE];
+
+	memset(end_padding, 0xcc, sizeof end_padding);
+	gcc_assert(debug_hooks == &rap_debug_hooks);
+
+	// chain to previous callback
+	if (old_debug_hooks && old_debug_hooks->begin_function)
+		old_debug_hooks->begin_function(decl);
+
+	// don't compute hash for functions called only directly
+	node = cgraph_get_node(decl);
+	gcc_assert(node);
+	if (!rap_cgraph_indirectly_callable(node)) {
+		imprecise_rap_hash.hash = 0;
+		return;
+	} else {
+		imprecise_rap_hash = rap_hash_function_node_imprecise(node);
+	}
+
+	gcc_assert(asprintf(&name, "__cfi_%s", IDENTIFIER_POINTER(DECL_ASSEMBLER_NAME(decl))) != -1);
+	if (TREE_PUBLIC(decl)) {
+		if (lookup_attribute("weak", DECL_ATTRIBUTES(decl)))
+			fprintf(asm_out_file, "\t.weak\t%s\n", name);
+		else
+			fprintf(asm_out_file, GLOBAL_ASM_OP " %s\n", name);
+	}
+
+	ASM_OUTPUT_TYPE_DIRECTIVE(asm_out_file, name, "function");
+	ASM_OUTPUT_LABEL(asm_out_file, name);
+
+	// align the rap hash if necessary
+	rap_hash_align(decl);
+
+	if (report_func_hash)
+		inform(DECL_SOURCE_LOCATION(decl), "func rap_hash: %x %s", imprecise_rap_hash.hash, IDENTIFIER_POINTER(DECL_ASSEMBLER_NAME(decl)));
+
+	fprintf(asm_out_file, "\t.long %#x\t%s __rap_hash_%s\n", imprecise_rap_hash.hash, ASM_COMMENT_START, IDENTIFIER_POINTER(DECL_ASSEMBLER_NAME(decl)));
+
+	ASM_OUTPUT_ASCII(asm_out_file, end_padding, sizeof end_padding);
+	fprintf(asm_out_file, "\t.size\t%s, .-%s\n", name, name);
+}
+
+static void rap_start_unit_common(void *gcc_data __unused, void *user_data __unused)
+{
+	rap_hash_type_node = long_integer_type_node;
+
+	if (debug_hooks)
+		rap_debug_hooks = *debug_hooks;
+	rap_debug_hooks.begin_function = rap_begin_function;
+	old_debug_hooks = debug_hooks;
+	debug_hooks = &rap_debug_hooks;
+}
+
+/*
+   emit an absolute symbol for each function that may be referenced through the plt
+     - all externs
+     - non-static functions
+       - use visibility instead?
+
+   .globl __rap_hash_func
+   .offset 0xhash_for_func
+   .type __rap_hash_func, @object
+   __rap_hash_func:
+   .previous
+*/
+static void rap_finish_unit(void *gcc_data __unused, void *user_data __unused)
+{
+	cgraph_node_ptr node;
+	rap_hash_t hash;
+
+	gcc_assert(debug_hooks == &rap_debug_hooks);
+
+	hash.hash = 0;
+	FOR_EACH_FUNCTION(node) {
+		tree fndecl;
+		const char *asmname;
+		char *name = NULL;
+
+		if (cgraph_function_body_availability(node) >= AVAIL_INTERPOSABLE) {
+			if (node->thunk || node->alias)
+				continue;
+			if (!rap_cgraph_indirectly_callable(node))
+				continue;
+		}
+
+#if BUILDING_GCC_VERSION >= 4007
+		gcc_assert(cgraph_function_or_thunk_node(node, NULL) == node);
+#endif
+
+		fndecl = NODE_DECL(node);
+		gcc_assert(fndecl);
+		if (DECL_IS_UNDECLARED_BUILTIN(fndecl) && DECL_BUILT_IN_CLASS(fndecl) == BUILT_IN_NORMAL)
+			continue;
+
+		if (!TREE_PUBLIC(fndecl))
+			continue;
+
+		if (DECL_ARTIFICIAL(fndecl))
+			continue;
+
+		if (DECL_ABSTRACT_ORIGIN(fndecl) && DECL_ABSTRACT_ORIGIN(fndecl) != fndecl)
+			continue;
+
+		gcc_assert(DECL_ASSEMBLER_NAME(fndecl));
+		asmname = IDENTIFIER_POINTER(DECL_ASSEMBLER_NAME(fndecl));
+		if (strchr(asmname, '.'))
+			continue;
+
+		if (asmname[0] == '*')
+			asmname++;
+
+		gcc_assert(asmname[0]);
+		gcc_assert(asprintf(&name, "__rap_hash_%s", asmname) != -1);
+
+		hash = rap_hash_function_node_imprecise(node);
+		if (report_abs_hash)
+			inform(DECL_SOURCE_LOCATION(fndecl), "abs rap_hash: %x %s", hash.hash, IDENTIFIER_POINTER(DECL_ASSEMBLER_NAME(fndecl)));
+
+		fprintf(asm_out_file, GLOBAL_ASM_OP " %s\n", name);
+		fprintf(asm_out_file, "\t.offset %#x\n", hash.hash);
+		ASM_OUTPUT_TYPE_DIRECTIVE(asm_out_file, name, "object");
+		ASM_OUTPUT_LABEL(asm_out_file, name);
+		free(name);
+	}
+
+	if (hash.hash)
+		fprintf(asm_out_file, "\t.previous\n");
+}
+
+#if BUILDING_GCC_VERSION >= 4007
+// emit the rap hash as an absolute symbol for all functions seen in the frontend
+// this is necessary as later unreferenced nodes will be removed yet we'd like to emit as many hashes as possible
+static void rap_finish_decl(void *event_data, void *data __unused)
+{
+	tree fndecl = (tree)event_data;
+	rap_hash_t hash;
+	const char *asmname;
+	char *name = NULL;
+
+	if (fndecl == error_mark_node)
+		return;
+
+	if (TREE_CODE(fndecl) != FUNCTION_DECL)
+		return;
+
+	if (!TREE_PUBLIC(fndecl))
+		return;
+
+	if (DECL_ARTIFICIAL(fndecl))
+		return;
+
+	if (DECL_ABSTRACT_ORIGIN(fndecl) && DECL_ABSTRACT_ORIGIN(fndecl) != fndecl)
+		return;
+
+	asmname = DECL_NAME_POINTER(fndecl);
+	gcc_assert(asmname[0]);
+
+	if (strchr(asmname, '.'))
+		return;
+
+	gcc_assert(asprintf(&name, "__rap_hash_%s", asmname) != -1);
+
+	hash = rap_hash_function_decl(fndecl, imprecise_rap_hash_flags);
+
+	if (report_abs_hash)
+		inform(DECL_SOURCE_LOCATION(fndecl), "abs rap_hash: %x %s", hash.hash, asmname);
+
+	fprintf(asm_out_file, GLOBAL_ASM_OP " %s\n", name);
+	if (TARGET_64BIT)
+		fprintf(asm_out_file, "\t.offset %#lx\n", (long)hash.hash);
+	else
+		fprintf(asm_out_file, "\t.offset %#x\n", hash.hash);
+	ASM_OUTPUT_TYPE_DIRECTIVE(asm_out_file, name, "object");
+	ASM_OUTPUT_LABEL(asm_out_file, name);
+	free(name);
+
+	fprintf(asm_out_file, "\t.previous\n");
+}
+#endif
+
+static bool rap_unignore_gate(void)
+{
+	if (!DECL_IGNORED_P(current_function_decl))
+		return false;
+
+	inform(DECL_SOURCE_LOCATION(current_function_decl), "DECL_IGNORED fixed");
+
+	DECL_IGNORED_P(current_function_decl) = 0;
+	return false;
+}
+
+#define PASS_NAME rap_unignore
+#define NO_EXECUTE
+#define TODO_FLAGS_FINISH TODO_dump_func
+#include "gcc-generate-rtl-pass.h"
+
+static bool rap_version_check(struct plugin_gcc_version *gcc_version, struct plugin_gcc_version *plugin_version)
+{
+	if (!gcc_version || !plugin_version)
+		return false;
+
+#if BUILDING_GCC_VERSION >= 5000
+	if (strncmp(gcc_version->basever, plugin_version->basever, 4))
+#else
+	if (strcmp(gcc_version->basever, plugin_version->basever))
+#endif
+		return false;
+	if (strcmp(gcc_version->datestamp, plugin_version->datestamp))
+		return false;
+	if (strcmp(gcc_version->devphase, plugin_version->devphase))
+		return false;
+	if (strcmp(gcc_version->revision, plugin_version->revision))
+		return false;
+//	if (strcmp(gcc_version->configuration_arguments, plugin_version->configuration_arguments))
+//		return false;
+	return true;
+}
+
+EXPORTED_CONST struct ggc_root_tab gt_ggc_r_gt_rap[] = {
+	{
+		.base = &rap_hash_type_node,
+		.nelt = 1,
+		.stride = sizeof(rap_hash_type_node),
+		.cb = &gt_ggc_mx_tree_node,
+		.pchw = &gt_pch_nx_tree_node
+	},
+	LAST_GGC_ROOT_TAB
+};
+
+static void
+handle_type_cast (void *gcc_data, void *user_data)
+{
+  (void) user_data;
+  tree *t = (tree *) gcc_data;
+  tree type = t[0];
+  tree otype = t[1];
+
+  if (TREE_CODE (type) == POINTER_TYPE
+      && TREE_CODE (otype) == POINTER_TYPE
+      && TREE_CODE (TREE_TYPE (type)) == FUNCTION_TYPE
+      && TREE_CODE (TREE_TYPE (otype)) == FUNCTION_TYPE
+//      && type != TYPE_MAIN_VARIANT (otype)
+      && TYPE_CANONICAL (TREE_TYPE (type)) != TYPE_CANONICAL (TREE_TYPE (otype)))
+        error (G_("cast from function type %qT "
+                  "to non-matching type %qT"), otype, type);
+
+}
+
+__visible int plugin_init(struct plugin_name_args *plugin_info, struct plugin_gcc_version *version)
+{
+	int i;
+	const char * const plugin_name = plugin_info->base_name;
+	const int argc = plugin_info->argc;
+	const struct plugin_argument * const argv = plugin_info->argv;
+	bool enable_call = false;
+	bool enable_abs = false, enable_abs_finish = false;
+
+	struct register_pass_info rap_fptr_pass_info;
+	struct register_pass_info rap_unignore_pass_info;
+
+	rap_fptr_pass_info.pass						= make_rap_fptr_pass();
+	rap_fptr_pass_info.reference_pass_name				= "nrv";
+	rap_fptr_pass_info.ref_pass_instance_number			= 1;
+	rap_fptr_pass_info.pos_op 					= PASS_POS_INSERT_AFTER;
+
+	rap_unignore_pass_info.pass					= make_rap_unignore_pass();
+	rap_unignore_pass_info.reference_pass_name			= "final";
+	rap_unignore_pass_info.ref_pass_instance_number			= 1;
+	rap_unignore_pass_info.pos_op 					= PASS_POS_INSERT_BEFORE;
+
+	if (!rap_version_check(version, &gcc_version)) {
+		error(G_("incompatible gcc/plugin versions"));
+		return 1;
+	}
+
+#if BUILDING_GCC_VERSION >= 5000
+	if (flag_ipa_icf_functions) {
+//		warning_at(UNKNOWN_LOCATION, 0, G_("-fipa-icf is incompatible with %s, disabling..."), plugin_name);
+//		inform(UNKNOWN_LOCATION, G_("-fipa-icf is incompatible with %s, disabling..."), plugin_name);
+		flag_ipa_icf_functions = 0;
+	}
+#endif
+
+	for (i = 0; i < argc; ++i) {
+		if (!strcmp(argv[i].key, "disable"))
+			continue;
+
+		if (!strcmp(argv[i].key, "check")) {
+			char *values, *value, *saveptr;
+
+			if (!argv[i].value) {
+				error(G_("no value supplied for option '-fplugin-arg-%s-%s'"), plugin_name, argv[i].key);
+				continue;
+			}
+
+			values = xstrdup(argv[i].value);
+			value = strtok_r(values, ",", &saveptr);
+			while (value) {
+				if (!strcmp(value, "call"))
+					enable_call = true;
+				else
+					error(G_("unknown value supplied for option '-fplugin-arg-%s-%s=%s'"), plugin_name, argv[i].key, value);
+				value = strtok_r(NULL, ",", &saveptr);
+			}
+			free(values);
+			continue;
+		}
+
+		if (!strcmp(argv[i].key, "hash")) {
+			char *values, *value, *saveptr;
+
+			if (!argv[i].value) {
+				error(G_("no value supplied for option '-fplugin-arg-%s-%s'"), plugin_name, argv[i].key);
+				continue;
+			}
+
+			values = xstrdup(argv[i].value);
+			value = strtok_r(values, ",", &saveptr);
+			while (value) {
+				if (!strcmp(value, "abs"))
+					enable_abs = enable_abs_finish = true;
+				else if (!strcmp(value, "abs-finish"))
+					enable_abs_finish = true;
+//				else if (!strcmp(value, "const"))
+//					imprecise_rap_hash_flags.qual_const = 1;
+//				else if (!strcmp(value, "volatile"))
+//					imprecise_rap_hash_flags.qual_volatile = 1;
+				else
+					error(G_("unknown value supplied for option '-fplugin-arg-%s-%s=%s'"), plugin_name, argv[i].key, value);
+				value = strtok_r(NULL, ",", &saveptr);
+			}
+			free(values);
+			continue;
+		}
+
+		if (!strcmp(argv[i].key, "report")) {
+			char *values, *value, *saveptr;
+
+			if (!argv[i].value) {
+				error(G_("no value supplied for option '-fplugin-arg-%s-%s'"), plugin_name, argv[i].key);
+				continue;
+			}
+
+			values = xstrdup(argv[i].value);
+			value = strtok_r(values, ",", &saveptr);
+			while (value) {
+				if (!strcmp(value, "func"))
+					report_func_hash = true;
+				else if (!strcmp(value, "fptr"))
+					report_fptr_hash = true;
+				else if (!strcmp(value, "abs"))
+					report_abs_hash = true;
+				else
+					error(G_("unknown value supplied for option '-fplugin-arg-%s-%s=%s'"), plugin_name, argv[i].key, value);
+				value = strtok_r(NULL, ",", &saveptr);
+			}
+			free(values);
+			continue;
+		}
+
+		error(G_("unkown option '-fplugin-arg-%s-%s'"), plugin_name, argv[i].key);
+	}
+
+	register_callback(plugin_name, PLUGIN_INFO, NULL, &rap_plugin_info);
+
+	if (enable_call) {
+		register_callback(plugin_name, PLUGIN_PASS_MANAGER_SETUP, NULL, &rap_fptr_pass_info);
+	}
+
+	if (enable_call || enable_abs_finish) {
+#if BUILDING_GCC_VERSION >= 4007
+		if (enable_abs)
+			register_callback(plugin_name, PLUGIN_FINISH_DECL, rap_finish_decl, NULL);
+#else
+#warning TODO
+#endif
+		register_callback(plugin_name, PLUGIN_PASS_MANAGER_SETUP, NULL, &rap_unignore_pass_info);
+		register_callback(plugin_name, PLUGIN_REGISTER_GGC_ROOTS, NULL, (void *)&gt_ggc_r_gt_rap);
+		register_callback(plugin_name, PLUGIN_START_UNIT, rap_start_unit_common, NULL);
+		if (enable_abs_finish)
+			register_callback(plugin_name, PLUGIN_FINISH_UNIT, rap_finish_unit, NULL);
+		register_callback(plugin_name, PLUGIN_ALL_IPA_PASSES_START, rap_calculate_func_hashes, NULL);
+		register_callback (plugin_name, PLUGIN_TYPE_CAST, handle_type_cast, NULL);
+	}
+	return 0;
+}
diff --git a/scripts/gcc-plugins/rap_plugin/sip.c b/scripts/gcc-plugins/rap_plugin/sip.c
new file mode 100644
index 000000000..65bc1cdea
--- /dev/null
+++ b/scripts/gcc-plugins/rap_plugin/sip.c
@@ -0,0 +1,96 @@
+// SipHash-2-4 adapted by the PaX Team from the public domain version written by
+//   Jean-Philippe Aumasson <jeanphilippe.aumasson@gmail.com>
+//   Daniel J. Bernstein <djb@cr.yp.to>
+
+#include <stdint.h>
+
+#define ROTL(x, b) (u64)(((x) << (b)) | ((x) >> (64 - (b))))
+
+#define U32TO8_LE(p, v)						\
+	(p)[0] = (u8)((v)      ); (p)[1] = (u8)((v) >>  8);	\
+	(p)[2] = (u8)((v) >> 16); (p)[3] = (u8)((v) >> 24);
+
+#define U64TO8_LE(p, v)				\
+	U32TO8_LE((p),     (u32)((v)      ));	\
+	U32TO8_LE((p) + 4, (u32)((v) >> 32));
+
+#define U8TO64_LE(p)	(	\
+	((u64)((p)[0])      ) |	\
+	((u64)((p)[1]) <<  8) |	\
+	((u64)((p)[2]) << 16) |	\
+	((u64)((p)[3]) << 24) |	\
+	((u64)((p)[4]) << 32) |	\
+	((u64)((p)[5]) << 40) |	\
+	((u64)((p)[6]) << 48) |	\
+	((u64)((p)[7]) << 56))
+
+#define SIPROUND							\
+do {									\
+	v0 += v1; v1 = ROTL(v1, 13); v1 ^= v0; v0 = ROTL(v0, 32);	\
+	v2 += v3; v3 = ROTL(v3, 16); v3 ^= v2;				\
+	v0 += v3; v3 = ROTL(v3, 21); v3 ^= v0;				\
+	v2 += v1; v1 = ROTL(v1, 17); v1 ^= v2; v2 = ROTL(v2, 32);	\
+} while(0)
+
+typedef uint64_t u64;
+typedef uint32_t u32;
+typedef uint8_t u8;
+
+/* SipHash-2-4 with previous output folding, a poor man's streaming interface */
+void siphash24fold(unsigned char *out, const unsigned char *in, unsigned long long inlen, const unsigned char *k);
+
+void siphash24fold(unsigned char *out, const unsigned char *in, unsigned long long inlen, const unsigned char *k)
+{
+	u64 k0 = U8TO64_LE(k);
+	u64 k1 = U8TO64_LE(k + 8);
+	/* "somepseudorandomlygeneratedbytes" */
+	u64 v0 = 0x736f6d6570736575ULL ^ k0;
+	u64 v1 = 0x646f72616e646f6dULL ^ k1;
+	u64 v2 = 0x6c7967656e657261ULL ^ k0;
+	u64 v3 = 0x7465646279746573ULL ^ k1;
+	u64 b, m;
+	const u8 * const end = in + inlen - (inlen % sizeof(u64));
+	const int left = inlen & 7;
+	b = ((u64)inlen) << 56;
+
+	// fold in the previous output
+	m = U8TO64_LE(out);
+	v3 ^= m;
+	SIPROUND;
+	SIPROUND;
+	v0 ^= m;
+
+	// consume full input blocks
+	for (; in != end; in += 8) {
+		m = U8TO64_LE(in);
+		v3 ^= m;
+		SIPROUND;
+		SIPROUND;
+		v0 ^= m;
+	}
+
+	// consume the last potentially partial block
+	switch (left) {
+	case 7: b |= ((u64)in[6]) << 48;
+	case 6: b |= ((u64)in[5]) << 40;
+	case 5: b |= ((u64)in[4]) << 32;
+	case 4: b |= ((u64)in[3]) << 24;
+	case 3: b |= ((u64)in[2]) << 16;
+	case 2: b |= ((u64)in[1]) <<  8;
+	case 1: b |= ((u64)in[0]); break;
+	case 0: break;
+	}
+
+	// finalize
+	v3 ^= b;
+	SIPROUND;
+	SIPROUND;
+	v0 ^= b;
+	v2 ^= 0xff;
+	SIPROUND;
+	SIPROUND;
+	SIPROUND;
+	SIPROUND;
+	b = v0 ^ v1 ^ v2 ^ v3;
+	U64TO8_LE(out, b);
+}
diff --git a/scripts/mod/modpost.c b/scripts/mod/modpost.c
index 686eed37f..2833ece61 100644
--- a/scripts/mod/modpost.c
+++ b/scripts/mod/modpost.c
@@ -1879,15 +1879,9 @@ static void check_exports(struct module *mod)
 		const char *basename;
 		exp = find_symbol(s->name);
 		if (!exp) {
-			if (!s->weak && nr_unresolved++ < MAX_UNRESOLVED_REPORTS)
-				modpost_log(warn_unresolved ? LOG_WARN : LOG_ERROR,
-					    "\"%s\" [%s.ko] undefined!\n",
-					    s->name, mod->name);
 			continue;
 		}
 		if (exp->module == mod) {
-			error("\"%s\" [%s.ko] was exported without definition\n",
-			      s->name, mod->name);
 			continue;
 		}
 
diff --git a/security/Kconfig b/security/Kconfig
index e6db09a77..148706453 100644
--- a/security/Kconfig
+++ b/security/Kconfig
@@ -5,6 +5,35 @@
 
 menu "Security options"
 
+menuconfig PAX
+	bool "Enable various PaX features"
+	depends on X86
+	help
+	  This allows you to enable various PaX features.  PaX adds
+	  intrusion prevention mechanisms to the kernel that reduce
+	  the risks posed by exploitable memory corruption bugs.
+
+if PAX
+config PAX_RAP
+	bool "Prevent code reuse attacks"
+	depends on X86_64 && GCC_PLUGINS
+	select CFI_CLANG
+	help
+	  By saying Y here the kernel will check indirect control transfers
+	  in order to detect and prevent attacks that try to hijack control
+	  flow by overwriting code pointers.
+
+	  If you have an amd64 processor that does not support SMEP then you
+	  must also enable a KERNEXEC code pointer instrumentation method
+	  (see PAX_KERNEXEC_PLUGIN).
+
+	  Note that binary modules cannot be instrumented by this approach.
+
+	  Note that the implementation requires a gcc with plugin support,
+	  i.e., gcc 4.5 or newer.  You may need to install the supporting
+	  headers explicitly in addition to the normal gcc package.
+endif
+
 source "security/keys/Kconfig"
 
 config SECURITY_DMESG_RESTRICT
diff --git a/security/apparmor/net.c b/security/apparmor/net.c
index 50e17fb0a..9d0b08cff 100644
--- a/security/apparmor/net.c
+++ b/security/apparmor/net.c
@@ -95,7 +95,7 @@ static void audit_unix_addr(struct audit_buffer *ab, const char *str,
 }
 
 static void audit_unix_sk_addr(struct audit_buffer *ab, const char *str,
-			       struct sock *sk)
+			       const struct sock *sk)
 {
 	struct unix_sock *u = unix_sk(sk);
 	if (u && u->addr)
-- 
2.23.1

